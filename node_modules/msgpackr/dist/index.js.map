{"version":3,"sources":["webpack://msgpackr/webpack/universalModuleDefinition","webpack://msgpackr/webpack/bootstrap","webpack://msgpackr/./unpack.mjs","webpack://msgpackr/./pack.mjs","webpack://msgpackr/./pack.js","webpack://msgpackr/./unpack.js","webpack://msgpackr/./browser.js","webpack://msgpackr/(webpack)/buildin/global.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Unpackr","Decoder","unpack","unpackMultiple","decode","addExtension","C1","mult10","typedArrays","C1Type","FLOAT32_OPTIONS","Packr","Encoder","pack","encode","unpackModule","textEncoder","extensions","extensionClasses","TextEncoder","error","hasNodeBuffer","Buffer","ByteArrayAllocate","allocUnsafeSlow","Uint8Array","ByteArray","MAX_BUFFER_SIZE","target","targetView","safeEnd","position","RECORD_SYMBOL","options","start","sharedStructures","hasSharedUpdate","structures","referenceMap","super","this","offset","lastSharedStructuresLength","encodeUtf8","utf8Write","string","maxBytes","encodeInto","subarray","written","packr","maxSharedStructures","isSequential","sequential","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","length","Error","DataView","buffer","structuredClone","Map","uninitialized","getStructures","sharedStructuresLength","transitions","keys","nextTransition","transition","nextId","idsToInsert","makeRoom","serialized","distanceToMove","lastEnd","sort","a","b","pop","id","copyWithin","insertIds","saveStructures","slice","type","headerSize","strLength","c1","c2","strPosition","charCodeAt","setUint32","setInt16","setInt32","useFloat32","xShifted","setFloat32","setFloat64","referee","push","set","constructor","writeObject","Array","size","entryValue","result","extension","currentTarget","currentTargetView","currentPosition","writeExtensionData","setBigInt64","setBigUint64","largeBigIntToFloat","RangeError","Number","useRecords","variableMapSize","safePrototype","objectOffset","newTransitions","recordId","shift","end","newSize","Math","min","round","max","newBuffer","copy","byteOffset","byteLength","writeExtBuffer","typedArray","allocateForWrite","writeBuffer","Date","Set","RegExp","ArrayBuffer","getPrototypeOf","date","seconds","getTime","useTimestamp32","getMilliseconds","BigInt","floor","array","from","message","regex","source","flags","arrayBuffer","indexOf","Class","unshift","defaultPackr","assign","decoder","src","srcEnd","TextDecoder","EMPTY_ARRAY","currentStructures","srcString","dataView","strings","stringPosition","currentUnpackr","srcStringStart","srcStringEnd","currentExtensions","defaultOptions","mapsAsObjects","undefined","continueReading","saveState","clearSource","read","forEach","values","defaultUnpackr","token","structure","createStructureReader","updatedStructures","splice","apply","concat","readKey","map","shortStringInJS","longStringInJS","readFixedString","readBin","getUint16","getUint32","readExt","getFloat32","multiplier","getFloat64","uint64AsNumber","getBigUint64","getInt8","getInt16","getInt32","getBigInt64","recordDefinition","readString8","readString16","readString32","readArray","readMap","incomplete","getPosition","validName","readObject","count","Function","test","JSON","stringify","join","readStringJS","units","byte1","byte2","byte3","unit","fromCharCode","String","setExtractor","extractStrings","readString","headerLength","extraction","srcStringLength","bytes","byte","e","f","g","h","j","k","copyBuffers","keyCache","chunk","entry","checkPosition","glbl","global","data","refEntry","targetProperties","used","callback","savedSrcEnd","savedPosition","savedStringPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedStrings","savedReferenceMap","savedSrc","savedStructures","savedPackr","typeCode","typedArrayName","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAkB,SAAID,IAEtBD,EAAe,SAAIC,IARrB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,+BClFrD,ydACO,MAAM,QAAEC,EAAO,QAAEC,EAAO,OAAEC,EAAM,eAAEC,EAAc,OAAEC,EAAM,aAAEC,EAAY,GAAEC,EAAE,OAAEC,EAAM,YAAEC,EAAW,OAAEC,EAAM,gBAAEC,GAAoB,G,6BCDpI,yQACO,MAAM,MAAEC,EAAK,QAAEC,EAAO,KAAEC,EAAI,OAAEC,EAAM,aAAET,EAAY,gBAAEK,GAAoB,G,6BCA/E,IAAIK,EAAe,EAAQ,GACvBf,EAAUe,EAAaf,QACvBO,EAASQ,EAAaR,OACtBE,EAASM,EAAaN,OAC1B,MAAMD,EAAcO,EAAaP,YACjC,IAAIQ,EAIAC,EAAYC,EAHhB,IACCF,EAAc,IAAIG,YACjB,MAAOC,IAET,MAAMC,EAAkC,oBAAXC,OACvBC,EAAoBF,EAAgBC,OAAOE,gBAAkBC,WAC7DC,EAAYL,EAAgBC,OAASG,WACrCE,EAAkBN,EAAgB,WAAc,WACtD,IAAIO,EACAC,EAEAC,EADAC,EAAW,EAEf,MAAMC,EAAgBjD,OAAO,aAC7B,MAAM4B,UAAcX,EACnB,YAAYiC,GAGX,IACIC,EACAC,EACAC,EACAC,EACAC,EAPJC,MAAMN,GACNO,KAAKC,OAAS,EAOd,IAAIC,EAA6B,EAC7BC,EAAajB,EAAU9B,UAAUgD,UAAY,SAASC,EAAQd,EAAUe,GAC3E,OAAOlB,EAAOgB,UAAUC,EAAQd,EAAUe,OACtC9B,IAAeA,EAAY+B,aAC/B,SAASF,EAAQd,GAChB,OAAOf,EAAY+B,WAAWF,EAAQjB,EAAOoB,SAASjB,IAAWkB,SAG/DC,EAAQV,KACRW,EAAsB,GACtBC,EAAenB,GAAWA,EAAQoB,WAClCD,IACHD,EAAsB,EACtBX,KAAKH,WAAa,IAEnB,IAAIiB,EAAoB,GACpBC,EAAmB,EACnBC,EAAuC,EAC3C,GAAIhB,KAAKH,YAAcG,KAAKH,WAAWoB,OAASN,EAC/C,MAAM,IAAIO,MAAM,8BAGjBlB,KAAK3B,KAAO2B,KAAK1B,OAAS,SAAS7B,GAiBlC,GAhBK2C,IACJA,EAAS,IAAIL,EAAkB,MAC/BM,EAAa,IAAI8B,SAAS/B,EAAOgC,OAAQ,EAAG,MAC5C7B,EAAW,GAEZD,EAAUF,EAAO6B,OAAS,GACtB3B,EAAUC,EAAW,OAExBH,EAAS,IAAIL,EAAkBK,EAAO6B,QACtC5B,EAAa,IAAI8B,SAAS/B,EAAOgC,OAAQ,EAAGhC,EAAO6B,QACnD3B,EAAUF,EAAO6B,OAAS,GAC1B1B,EAAW,GAEZG,EAAQH,EACRO,EAAeY,EAAMW,gBAAkB,IAAIC,IAAQ,KACnD3B,EAAmBe,EAAMb,WACrBF,EAAkB,CACjBA,EAAiB4B,gBACpBb,EAAMb,WAAaF,EAAmBe,EAAMc,iBAC7C,IAAIC,EAAyB9B,EAAiBsB,OAG9C,GAFIQ,EAA0Bd,IAAwBC,IACrDa,EAAyBd,IACrBhB,EAAiB+B,YAAa,CAElC/B,EAAiB+B,YAAcxF,OAAOY,OAAO,MAC7C,IAAK,IAAItB,EAAI,EAAGA,EAAIiG,EAAwBjG,IAAK,CAChD,IAAImG,EAAOhC,EAAiBnE,GAC5B,IAAKmG,EACJ,SACD,IAAIC,EAAgBC,EAAalC,EAAiB+B,YAClD,IAAK,IAAIlG,EAAG,EAAGC,EAAIkG,EAAKV,OAAQzF,EAAIC,EAAGD,IAAK,CAC3C,IAAIuB,EAAM4E,EAAKnG,GACfoG,EAAiBC,EAAW9E,GACvB6E,IACJA,EAAiBC,EAAW9E,GAAOb,OAAOY,OAAO,OAElD+E,EAAaD,EAEdC,EAAWrC,GAAiBhE,EAAI,GAEjC0E,EAA6BP,EAAiBsB,OAE1CL,IACJjB,EAAiBmC,OAASL,EAAyB,IAEjD7B,IACHA,GAAkB,GACnBC,EAAaF,GAAoB,GACjC,IAGC,GAFAtB,EAAK5B,GACLiE,EAAMT,OAASV,EACXO,GAAgBA,EAAaiC,YAAa,CAC7CxC,GAA8C,EAAlCO,EAAaiC,YAAYd,OACjC1B,EAAWD,GACd0C,EAASzC,GACVmB,EAAMT,OAASV,EACf,IAAI0C,EAsmBT,SAAmBA,EAAYF,GAE9B,IAAID,EACAI,EAAsC,EAArBH,EAAYd,OAC7BkB,EAAUF,EAAWhB,OAASiB,EAClCH,EAAYK,KAAK,CAACC,EAAGC,IAAMD,EAAEpC,OAASqC,EAAErC,OAAS,GAAK,GACtD,KAAO6B,EAASC,EAAYQ,OAAO,CAClC,IAAItC,EAAS6B,EAAO7B,OAChBuC,EAAKV,EAAOU,GAChBP,EAAWQ,WAAWxC,EAASiC,EAAgBjC,EAAQkC,GACvDD,GAAkB,EAClB,IAAI3C,EAAWU,EAASiC,EACxBD,EAAW1C,KAAc,IACzB0C,EAAW1C,KAAc,IACzB0C,EAAW1C,KAAciD,GAAM,GAC/BP,EAAW1C,KAAeiD,GAAM,GAAM,IACtCP,EAAW1C,KAAeiD,GAAM,EAAK,IACrCP,EAAW1C,KAAmB,IAALiD,EACzBL,EAAUlC,EAEX,OAAOgC,EA1nBcS,CAAUtD,EAAOoB,SAASd,EAAOH,GAAWO,EAAaiC,aAE1E,OADAjC,EAAe,KACRmC,EAER,OAAO7C,EAAOoB,SAASd,EAAOH,GAC7B,QACD,GAAII,EAAkB,CAGrB,GAFIqB,EAAuC,IAC1CA,IACGD,EAAmB,IAEtBpB,EAAiB+B,YAAc,KAC/BV,EAAuC,EACvCD,EAAmB,EACfD,EAAkBG,OAAS,IAC9BH,EAAoB,SACf,GAAIA,EAAkBG,OAAS,IAAML,EAAc,CACzD,IAAK,IAAIpF,EAAI,EAAGC,EAAIqF,EAAkBG,OAAQzF,EAAIC,EAAGD,IACpDsF,EAAkBtF,GAAGgE,GAAiB,EAEvCsB,EAAoB,GAErB,GAAIlB,GAAmBc,EAAMiC,eAAgB,CAK5C,GAJIjC,EAAMb,WAAWoB,OAASN,IAC7BD,EAAMb,WAAaa,EAAMb,WAAW+C,MAAM,EAAGjC,KAG6B,IAAvED,EAAMiC,eAAejC,EAAMb,WAAYK,GAG1C,OADAQ,EAAMb,WAAaa,EAAMc,iBAAmB,GACrCd,EAAMrC,KAAK5B,GAEnByD,EAA6BQ,EAAMb,WAAWoB,WAKlD,MAAM5C,EAAQ5B,IACT8C,EAAWD,IACdF,EAAS4C,EAASzC,IAEnB,IACI0B,EADA4B,SAAcpG,EAElB,GAAa,WAAToG,EAAmB,CACtB,IACIC,EADAC,EAAYtG,EAAMwE,OAIrB6B,EADGC,EAAY,GACF,EACHA,EAAY,IACT,EACHA,EAAY,MACT,EAEA,EAEd,IAAIzC,EAAuB,EAAZyC,EAIf,GAHIxD,EAAWe,EAAWhB,IACzBF,EAAS4C,EAASzC,EAAWe,IAE1ByC,EAAY,KAAS5C,EAAY,CACpC,IAAI3E,EAAGwH,EAAIC,EAAIC,EAAc3D,EAAWuD,EACxC,IAAKtH,EAAI,EAAGA,EAAIuH,EAAWvH,IAC1BwH,EAAKvG,EAAM0G,WAAW3H,GAClBwH,EAAK,IACR5D,EAAO8D,KAAiBF,EACdA,EAAK,MACf5D,EAAO8D,KAAiBF,GAAM,EAAI,IAClC5D,EAAO8D,KAAsB,GAALF,EAAY,KAElB,QAAZ,MAALA,IAC6C,QAAZ,OAAhCC,EAAKxG,EAAM0G,WAAW3H,EAAI,MAE5BwH,EAAK,QAAiB,KAALA,IAAgB,KAAY,KAALC,GACxCzH,IACA4D,EAAO8D,KAAiBF,GAAM,GAAK,IACnC5D,EAAO8D,KAAiBF,GAAM,GAAK,GAAO,IAC1C5D,EAAO8D,KAAiBF,GAAM,EAAI,GAAO,IACzC5D,EAAO8D,KAAsB,GAALF,EAAY,MAEpC5D,EAAO8D,KAAiBF,GAAM,GAAK,IACnC5D,EAAO8D,KAAiBF,GAAM,EAAI,GAAO,IACzC5D,EAAO8D,KAAsB,GAALF,EAAY,KAGtC/B,EAASiC,EAAc3D,EAAWuD,OAElC7B,EAASd,EAAW1D,EAAO8C,EAAWuD,EAAYxC,GAG/CW,EAAS,GACZ7B,EAAOG,KAAc,IAAO0B,EAClBA,EAAS,KACf6B,EAAa,GAChB1D,EAAOqD,WAAWlD,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAI0B,GAE9D7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GACXA,EAAS,OACf6B,EAAa,GAChB1D,EAAOqD,WAAWlD,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAI0B,GAE9D7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GAAU,EAC/B7B,EAAOG,KAAuB,IAAT0B,IAEjB6B,EAAa,GAChB1D,EAAOqD,WAAWlD,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAI0B,GAE9D7B,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAU0B,GAC/B1B,GAAY,GAEbA,GAAY0B,OACN,GAAa,WAAT4B,EACV,GAAIpG,IAAU,IAAMA,EAEfA,EAAQ,GACX2C,EAAOG,KAAc9C,EACXA,EAAQ,KAClB2C,EAAOG,KAAc,IACrBH,EAAOG,KAAc9C,GACXA,EAAQ,OAClB2C,EAAOG,KAAc,IACrBH,EAAOG,KAAc9C,GAAS,EAC9B2C,EAAOG,KAAsB,IAAR9C,IAErB2C,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAU9C,GAC/B8C,GAAY,QAEP,GAAI9C,GAAS,IAAMA,EACrBA,IAAU,GACb2C,EAAOG,KAAc,IAAQ9C,EACnBA,IAAU,KACpB2C,EAAOG,KAAc,IACrBH,EAAOG,KAAc9C,EAAQ,KACnBA,IAAU,OACpB2C,EAAOG,KAAc,IACrBF,EAAWgE,SAAS9D,EAAU9C,GAC9B8C,GAAY,IAEZH,EAAOG,KAAc,IACrBF,EAAWiE,SAAS/D,EAAU9C,GAC9B8C,GAAY,OAEP,CACN,IAAIgE,EACJ,IAAKA,EAAavD,KAAKuD,YAAc,GAAK9G,EAAQ,YAAeA,IAAU,WAAY,CAGtF,IAAI+G,EACJ,GAHApE,EAAOG,KAAc,IACrBF,EAAWoE,WAAWlE,EAAU9C,GAE5B8G,EAAa,IAEbC,EAAW/G,EAAQsB,GAA4B,IAAnBqB,EAAOG,KAAqB,EAAMH,EAAOG,EAAW,IAAM,KAAQ,IAAOiE,EAExG,YADAjE,GAAY,GAGZA,IAEFH,EAAOG,KAAc,IACrBF,EAAWqE,WAAWnE,EAAU9C,GAChC8C,GAAY,OAEP,GAAa,WAATsD,EACV,GAAKpG,EAEA,CACJ,GAAIqD,EAAc,CACjB,IAAI6D,EAAU7D,EAAazD,IAAII,GAC/B,GAAIkH,EAAS,CACZ,IAAKA,EAAQnB,GAAI,CAChB,IAAIT,EAAcjC,EAAaiC,cAAgBjC,EAAaiC,YAAc,IAC1E4B,EAAQnB,GAAKT,EAAY6B,KAAKD,GAM/B,OAJAvE,EAAOG,KAAc,IACrBH,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAUoE,EAAQnB,SACvCjD,GAAY,GAGZO,EAAa+D,IAAIpH,EAAO,CAAEwD,OAAQV,EAAWG,IAE/C,IAAIoE,EAAcrH,EAAMqH,YACxB,GAAIA,IAAgB5H,OACnB6H,EAAYtH,GAAO,QACb,GAAIqH,IAAgBE,MAAO,EACjC/C,EAASxE,EAAMwE,QACF,GACZ7B,EAAOG,KAAc,IAAO0B,EAClBA,EAAS,OACnB7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GAAU,EAC/B7B,EAAOG,KAAuB,IAAT0B,IAErB7B,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAU0B,GAC/B1B,GAAY,GAEb,IAAK,IAAI/D,EAAI,EAAGA,EAAIyF,EAAQzF,IAC3B6C,EAAK5B,EAAMjB,SAEN,GAAIsI,IAAgBxC,IAAK,EAC/BL,EAASxE,EAAMwH,MACF,GACZ7E,EAAOG,KAAc,IAAO0B,EAClBA,EAAS,OACnB7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GAAU,EAC/B7B,EAAOG,KAAuB,IAAT0B,IAErB7B,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAU0B,GAC/B1B,GAAY,GAEb,IAAK,IAAMxC,EAAKmH,KAAgBzH,EAC/B4B,EAAKtB,GACLsB,EAAK6F,OAEA,CACN,IAAK,IAAI1I,EAAI,EAAGC,EAAIgD,EAAWwC,OAAQzF,EAAIC,EAAGD,IAAK,CAElD,GAAIiB,aADiBiC,EAAiBlD,GACD,CACpC,IAKI2I,EALAC,EAAY3F,EAAWjD,GACvB6I,EAAgBjF,EAChBkF,EAAoBjF,EACpBkF,EAAkBhF,EACtBH,EAAS,KAET,IACC+E,EAASC,EAAU/F,KAAK1C,KAAKqE,KAAMvD,EAAQwH,IAE1C7E,EAASiF,EACTA,EAAgB,KAChB9E,GAAY0E,EACR1E,EAAWD,GACd0C,EAASzC,GACH,CACNH,SAAQC,aAAYE,SAAUA,EAAW0E,IAExC5F,GACF,QAEGgG,IACHjF,EAASiF,EACThF,EAAaiF,EACb/E,EAAWgF,EACXjF,EAAUF,EAAO6B,OAAS,IAM5B,YAHIkD,IACH5E,EAAWiF,EAAmBL,EAAQ/E,EAAQG,EAAU6E,EAAUvB,SAMrEkB,EAAYtH,GAAQA,EAAMY,sBA3F3B+B,EAAOG,KAAc,SA8FhB,GAAa,YAATsD,EACVzD,EAAOG,KAAc9C,EAAQ,IAAO,SAC9B,GAAa,WAAToG,EAAmB,CAC7B,GAAIpG,EAAS,IAAI,KAAQA,KAAW,IAAI,KAEvC2C,EAAOG,KAAc,IACrBF,EAAWoF,YAAYlF,EAAU9C,QAC3B,GAAIA,EAAS,IAAI,KAAQA,EAAQ,EAEvC2C,EAAOG,KAAc,IACrBF,EAAWqF,aAAanF,EAAU9C,OAC5B,CAEN,IAAIuD,KAAK2E,mBAIR,MAAM,IAAIC,WAAWnI,EAAQ,6GAH7B2C,EAAOG,KAAc,IACrBF,EAAWqE,WAAWnE,EAAUsF,OAAOpI,IAKzC8C,GAAY,MACN,IAAa,cAATsD,EAMV,MAAM,IAAI3B,MAAM,gBAAkB2B,GAJlCzD,EAAOG,KAAc,IACrBH,EAAOG,KAAc,EACrBH,EAAOG,KAAc,IAMjBwE,GAAkC,IAApB/D,KAAK8E,WAAuB9E,KAAK+E,gBAAmB7H,IAEvE,IAaIH,EAbA4E,EAAOzF,OAAOyF,KAAKzE,GACnB+D,EAASU,EAAKV,OACdA,EAAS,GACZ7B,EAAOG,KAAc,IAAO0B,EAClBA,EAAS,OACnB7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GAAU,EAC/B7B,EAAOG,KAAuB,IAAT0B,IAErB7B,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAU0B,GAC/B1B,GAAY,GAGb,IAAK,IAAI/D,EAAI,EAAGA,EAAIyF,EAAQzF,IAC3B6C,EAAKtB,EAAM4E,EAAKnG,IAChB6C,EAAKnB,EAAOH,KAGd,CAACG,EAAQ8H,KACR5F,EAAOG,KAAc,IACrB,IAAI0F,EAAe1F,EAAWG,EAC9BH,GAAY,EACZ,IAAI0E,EAAO,EACX,IAAK,IAAIlH,KAAOG,GACX8H,GAAiB9H,EAAOG,eAAeN,MAC1CsB,EAAKtB,GACLsB,EAAKnB,EAAOH,IACZkH,KAGF7E,EAAO6F,IAAiBvF,GAASuE,GAAQ,EACzC7E,EAAO6F,EAAevF,GAAgB,IAAPuE,GA2C/B/G,IACA,IACI0E,EADAD,EAAOzF,OAAOyF,KAAKzE,GACH2E,EAAahC,EAAW6B,cAAgB7B,EAAW6B,YAAcxF,OAAOY,OAAO,OAC/FoI,EAAiB,EACrB,IAAK,IAAI1J,EAAG,EAAGC,EAAIkG,EAAKV,OAAQzF,EAAIC,EAAGD,IAAK,CAC3C,IAAIuB,EAAM4E,EAAKnG,GACfoG,EAAiBC,EAAW9E,GACvB6E,IACJA,EAAiBC,EAAW9E,GAAOb,OAAOY,OAAO,MACjDoI,KAEDrD,EAAaD,EAEd,IAAIuD,EAAWtD,EAAWrC,GACtB2F,EACH/F,EAAOG,KAAc4F,GAErBA,EAAWtF,EAAWiC,SACjBqD,IACJA,EAAW,GACXtF,EAAWiC,OAAS,IAEjBqD,GAAY,MACftF,EAAWiC,QAAUqD,EAAWxE,EAAsB,IAAQ,GAE/DkB,EAAWrC,GAAiB2F,EAC5BtF,EAAW,GAAOsF,GAAYxD,EAC1BhC,GAAoBA,EAAiBsB,QAAUN,GAClDvB,EAAOG,KAAc4F,EACrBvF,GAAkB,IAElBR,EAAOG,KAAc,IACrBH,EAAOG,KAAc,IACrBH,EAAOG,KAAc4F,EACjBD,IACHnE,GAAoBC,EAAuCkE,GAExDpE,EAAkBG,QAAU,GAAON,IACtCG,EAAkBsE,QAAQ5F,GAAiB,GAC5CsB,EAAkB8C,KAAK/B,GACvBxD,EAAKsD,KAIP,IAAK,IAAInG,EAAG,EAAGC,EAAIkG,EAAKV,OAAQzF,EAAIC,EAAGD,IACtC6C,EAAKnB,EAAOyE,EAAKnG,MAEbwG,EAAYqD,IACjB,IAAIC,EACJ,GAAID,EAAM,SAAW,CAEpB,GAAKA,EAAM3F,EAASP,EACnB,MAAM,IAAI+B,MAAM,0DACjBoE,EAAUC,KAAKC,IAAIrG,EACuE,KAAzFoG,KAAKE,MAAMF,KAAKG,KAAKL,EAAM3F,IAAU2F,EAAM,SAAY,KAAO,GAAI,UAAa,YAEhFC,EAAqE,GAAzDC,KAAKG,IAAKL,EAAM3F,GAAU,EAAGN,EAAO6B,OAAS,IAAM,KAAY,GAC5E,IAAI0E,EAAY,IAAI5G,EAAkBuG,GAStC,OARAjG,EAAa,IAAI8B,SAASwE,EAAUvE,OAAQ,EAAGkE,GAC3ClG,EAAOwG,KACVxG,EAAOwG,KAAKD,EAAW,EAAGjG,EAAO2F,GAEjCM,EAAU9B,IAAIzE,EAAOwD,MAAMlD,EAAO2F,IACnC9F,GAAYG,EACZA,EAAQ,EACRJ,EAAUqG,EAAU1E,OAAS,GACtB7B,EAASuG,GAGlB,UAAUvE,GAEThC,EAASgC,EACT/B,EAAa,IAAI8B,SAAS/B,EAAOgC,OAAQhC,EAAOyG,WAAYzG,EAAO0G,YACnEvG,EAAW,GA2Fb,SAASwG,EAAeC,EAAYnD,EAAMoD,EAAkB3H,GAC3D,IAAI2C,EAAS+E,EAAWF,WACxB,GAAI7E,EAAS,EAAI,IAAO,CACvB,IAAI,OAAE7B,EAAM,SAAEG,GAAa0G,EAAiB,EAAIhF,GAChD7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,EAAS,OACxB,GAAIA,EAAS,EAAI,MAAS,CAChC,IAAI,OAAE7B,EAAM,SAAEG,GAAa0G,EAAiB,EAAIhF,GAChD7B,EAAOG,KAAc,IACrBH,EAAOG,KAAe0B,EAAS,GAAM,EACrC7B,EAAOG,KAAe0B,EAAS,EAAK,QAC9B,CACN,IAAI,OAAE7B,EAAM,SAAEG,EAAQ,WAAEF,GAAe4G,EAAiB,EAAIhF,GAC5D7B,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAU0B,EAAS,GACxC1B,GAAY,EAEbH,EAAOG,KAAc,IACrBH,EAAOG,KAAcsD,EACrBzD,EAAOyE,IAAI,IAAI5E,WAAW+G,EAAW5E,OAAQ4E,EAAWH,WAAYG,EAAWF,YAAavG,GAE7F,SAAS2G,EAAY9E,EAAQ6E,GAC5B,IAAIhF,EAASG,EAAO0E,WACpB,IAAI1G,EAAQG,EACZ,GAAI0B,EAAS,IAAO,CACnB,IAAI,OAAE7B,EAAM,SAAEG,GAAa0G,EAAiBhF,EAAS,GACrD7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,OACf,GAAIA,EAAS,MAAS,CAC5B,IAAI,OAAE7B,EAAM,SAAEG,GAAa0G,EAAiBhF,EAAS,GACrD7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GAAU,EAC/B7B,EAAOG,KAAuB,IAAT0B,MACf,CACN,IAAI,OAAE7B,EAAM,SAAEG,EAAQ,WAAEF,GAAe4G,EAAiBhF,EAAS,GACjE7B,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAU0B,GAC/B1B,GAAY,EAEbH,EAAOyE,IAAIzC,EAAQ7B,GAGpB,SAASiF,EAAmBL,EAAQ/E,EAAQG,EAAUsD,GACrD,IAAI5B,EAASkD,EAAOlD,OACpB,OAAQA,GACP,KAAK,EACJ7B,EAAOG,KAAc,IACrB,MACD,KAAK,EACJH,EAAOG,KAAc,IACrB,MACD,KAAK,EACJH,EAAOG,KAAc,IACrB,MACD,KAAK,EACJH,EAAOG,KAAc,IACrB,MACD,KAAK,GACJH,EAAOG,KAAc,IACrB,MACD,QACK0B,EAAS,KACZ7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GACXA,EAAS,OACnB7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GAAU,EAC/B7B,EAAOG,KAAuB,IAAT0B,IAErB7B,EAAOG,KAAc,IACrBH,EAAOG,KAAc0B,GAAU,GAC/B7B,EAAOG,KAAe0B,GAAU,GAAM,IACtC7B,EAAOG,KAAe0B,GAAU,EAAK,IACrC7B,EAAOG,KAAuB,IAAT0B,GAMxB,OAHA7B,EAAOG,KAAcsD,EACrBzD,EAAOyE,IAAIM,EAAQ5E,GACnBA,GAAY0B,EAtKbjG,EAAQmD,MAAQA,EAQhBO,EAAmB,CAAEyH,KAAMC,IAAKlF,MAAOmF,OAAQC,YAAapK,OAAOqK,eAAetH,WAAW7B,WAAW0G,YAA4B7F,GACpIQ,EAAa,CAAC,CACb,KAAK+H,EAAMP,GACV,IAAIQ,EAAUD,EAAKE,UAAY,IAC/B,IAAK1G,KAAK2G,gBAA6C,IAA3BH,EAAKI,oBAA4BH,GAAW,GAAKA,EAAU,WAAa,CAEnG,IAAI,OAAErH,EAAM,WAAEC,EAAU,SAAEE,GAAY0G,EAAiB,GACvD7G,EAAOG,KAAc,IACrBH,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAUkH,QACzB,GAAIA,EAAU,GAAKA,EAAU,YAAa,CAEhD,IAAI,OAAErH,EAAM,WAAEC,EAAU,SAAEE,GAAY0G,EAAiB,IACvD7G,EAAOG,KAAc,IACrBH,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAmC,IAAzBiH,EAAKI,mBAAgCH,EAAU,IAAO,YAAgB,IACrGpH,EAAW+D,UAAU7D,EAAW,EAAGkH,OAC7B,CAEN,IAAI,OAAErH,EAAM,WAAEC,EAAU,SAAEE,GAAY0G,EAAiB,IACvD7G,EAAOG,KAAc,IACrBH,EAAOG,KAAc,GACrBH,EAAOG,KAAc,IACrBF,EAAW+D,UAAU7D,EAAmC,IAAzBiH,EAAKI,mBACpCvH,EAAWoF,YAAYlF,EAAW,EAAGsH,OAAOtB,KAAKuB,MAAML,QAGvD,CACF,KAAK5C,EAAKoC,EAAkB5H,GAC3B,IAAI0I,EAAQ/C,MAAMgD,KAAKnD,GACvB,GAAI7D,KAAKqB,gBAAiB,CACzB,IAAI,OAAEjC,EAAM,SAAEG,GAAY0G,EAAiB,GAC3C7G,EAAOG,KAAc,IACrBH,EAAOG,KAAc,IACrBH,EAAOG,KAAc,EAEtBlB,EAAK0I,KAEJ,CACF,KAAKnI,EAAOqH,EAAkB5H,GAC7B,GAAI2B,KAAKqB,gBAAiB,CACzB,IAAI,OAAEjC,EAAM,SAAEG,GAAY0G,EAAiB,GAC3C7G,EAAOG,KAAc,IACrBH,EAAOG,KAAc,IACrBH,EAAOG,KAAc,EAEtBlB,EAAK,CAAEO,EAAM7C,KAAM6C,EAAMqI,YAExB,CACF,KAAKC,EAAOjB,EAAkB5H,GAC7B,GAAI2B,KAAKqB,gBAAiB,CACzB,IAAI,OAAEjC,EAAM,SAAEG,GAAY0G,EAAiB,GAC3C7G,EAAOG,KAAc,IACrBH,EAAOG,KAAc,IACrBH,EAAOG,KAAc,EAEtBlB,EAAK,CAAE6I,EAAMC,OAAQD,EAAME,UAE1B,CACF,KAAKC,EAAapB,GACbjG,KAAKqB,gBACR0E,EAAesB,EAAa,GAAMpB,GAElCC,EAAYrH,EAAgBC,OAAOkI,KAAKK,GAAe,IAAIpI,WAAWoI,GAAcpB,KAEpF,CACF,KAAKD,EAAYC,GAChB,IAAInC,EAAckC,EAAWlC,YACzBA,IAAgB5E,GAAac,KAAKqB,gBACrC0E,EAAeC,EAAYhI,EAAYsJ,QAAQxD,EAAY/H,MAAOkK,GAElEC,EAAYF,EAAYC,KAExB,CACF,KAAKjD,EAAIiD,GACR,IAAI,OAAE7G,EAAM,SAAEG,GAAY0G,EAAiB,GAC3C7G,EAAOG,GAAY,OA6GrBvE,EAAQ6C,aAAe,SAASuG,GAC/B,GAAIA,EAAUmD,MAAO,CACpB,IAAKnD,EAAU/F,KACd,MAAM,IAAI6C,MAAM,kCACjBxC,EAAiB8I,QAAQpD,EAAUmD,OACnC9I,EAAW+I,QAAQpD,GAEpB7F,EAAaV,aAAauG,IAG3B,IAAIqD,EAAe,IAAItJ,EAAM,CAAE2G,YAAY,IAC3C9J,EAAQqD,KAAOoJ,EAAapJ,KAC5BrD,EAAQsD,OAASmJ,EAAapJ,KAC9BnC,OAAOwL,OAAO1M,EAASA,EAAQkD,gBAAkBK,EAAaL,kB,8BCvvB9D,YACA,IAAIyJ,EAIAC,EACAC,EAJJ,IACCF,EAAU,IAAIG,YACb,MAAMlJ,IAGR,IAAIW,EAAW,EAEf,MAAMwI,EAAc,GACpB,IAGIC,EACAC,EAGAnI,EAEAoI,EATAC,EAAUJ,EACVK,EAAiB,EACjBC,EAAiB,GAGjBC,EAAiB,EACjBC,EAAe,EAEfC,EAAoB,GAEpBC,EAAiB,CACpB3D,YAAY,EACZ4D,eAAe,GAEhB,MAAMzK,GACN,MAAMH,EAAK,IAAIG,EACfH,EAAG/B,KAAO,mBAEV,MAAMyB,EACL,YAAYiC,GACPA,KACwB,IAAvBA,EAAQqF,iBAAkD6D,IAA1BlJ,EAAQiJ,gBAC3CjJ,EAAQiJ,eAAgB,GACrBjJ,EAAQ+B,gBAAkB/B,EAAQI,cACpCJ,EAAQI,WAAa,IAAI0B,eAAgB,IAE5CrF,OAAOwL,OAAO1H,KAAMP,GAErB,OAAO0H,EAAQ9B,EAAKuD,GACnB,GAAIhB,EAEH,OAAOiB,EAAU,KAChBC,IACO9I,KAAOA,KAAKtC,OAAOyJ,EAAQ9B,EAAKuD,GAAmBpL,EAAQJ,UAAUM,OAAO/B,KAAK8M,EAAgBtB,EAAQ9B,EAAKuD,KAcvH,GAXAf,EAASxC,GAAO,EAAIA,EAAM8B,EAAOlG,OACjC1B,EAAW,EACX6I,EAAiB,EACjBG,EAAe,EACfN,EAAY,KACZE,EAAUJ,EACVH,EAAMT,EAINe,EAAWf,EAAOe,WAAaf,EAAOe,SAAW,IAAI/G,SAASgG,EAAO/F,OAAQ+F,EAAOtB,WAAYsB,EAAOrB,aACnG9F,KAEH,GADAqI,EAAiBrI,KACbA,KAAKH,WAAY,CACpBmI,EAAoBhI,KAAKH,WACzB,IACC,OAAOkJ,IACN,SACGxJ,GAAYsI,IAAWe,KAE1BZ,EAAoB,KACpBJ,EAAM,KACF9H,IACHA,EAAe,cAGPkI,GAAqBA,EAAkB/G,OAAS,KAC3D+G,EAAoB,SAGrBK,EAAiBI,IACZT,GAAqBA,EAAkB/G,OAAS,KACpD+G,EAAoB,IAEtB,IACC,OAAOe,IACN,SACGxJ,GAAYsI,IAAWe,KAC1BhB,EAAM,KACF9H,IACHA,EAAe,QAInB,eAAeqH,EAAQ6B,GACtB,IACC,IAGIC,EAFAhF,EAAOkD,EAAOlG,OACdxE,EAAQuD,KAAOA,KAAKtC,OAAOyJ,EAAQlD,GAAM,GAAQiF,EAAexL,OAAOyJ,EAAQlD,GAAM,GAEzF,IAAI+E,EAQC,CAEJ,IADAC,EAAS,CAAExM,GACL8C,EAAW0E,GAChBgF,EAAOrF,KAAKmF,KAEb,OAAOE,EAXP,IADAD,EAAQvM,GACF8C,EAAW0E,GAChB,IAAwB,IAApB+E,EAAQD,KACX,OAWF,QACDD,KAGF,OAAO3B,EAAQ9B,GACd,OAAOrF,KAAKtC,OAAOyJ,EAAQ9B,IAS7B,SAAS0D,IACR,IAAII,EAAQvB,EAAIrI,KAChB,GAAI4J,EAAQ,IAAM,CACjB,GAAIA,EAAQ,IAAM,CACjB,GAAIA,EAAQ,GACX,OAAOA,EACH,CACJ,IAAIC,EAAYpB,EAA0B,GAARmB,GAClC,GAAIC,EAGH,OAFKA,EAAUL,OACdK,EAAUL,KAAOM,EAAsBD,IACjCA,EAAUL,OACX,GAAIV,EAAe7G,cAAe,CACxC,IAAI8H,EAAoBT,EAAU,KAEjCjB,EAAM,KACCS,EAAe7G,kBAOvB,OAL0B,IAAtBwG,EACHK,EAAexI,WAAamI,EAAoBsB,EAEhDtB,EAAkBuB,OAAOC,MAAMxB,EAAmB,CAAC,EAAGsB,EAAkBrI,QAAQwI,OAAOH,IACxFF,EAAYpB,EAA0B,GAARmB,GAC1BC,GACEA,EAAUL,OACdK,EAAUL,KAAOM,EAAsBD,IACjCA,EAAUL,QAEVI,EAER,OAAOA,GAEH,GAAIA,EAAQ,IAAM,CAGxB,GADAA,GAAS,IACLd,EAAeK,cAAe,CACjC,IAAIxL,EAAS,GACb,IAAK,IAAI1B,EAAI,EAAGA,EAAI2N,EAAO3N,IAC1B0B,EAAOwM,KAAaX,IAErB,OAAO7L,EACD,CACN,IAAIyM,EAAM,IAAIrI,IACd,IAAK,IAAI9F,EAAI,EAAGA,EAAI2N,EAAO3N,IAC1BmO,EAAI9F,IAAIkF,IAAQA,KAEjB,OAAOY,GAEF,CACNR,GAAS,IACT,IAAIpC,EAAQ,IAAI/C,MAAMmF,GACtB,IAAK,IAAI3N,EAAI,EAAGA,EAAI2N,EAAO3N,IAC1BuL,EAAMvL,GAAKuN,IAEZ,OAAOhC,GAEF,GAAIoC,EAAQ,IAAM,CAExB,IAAIlI,EAASkI,EAAQ,IACrB,GAAIZ,GAAgBhJ,EACnB,OAAO0I,EAAUrF,MAAMrD,EAAW+I,GAAiB/I,GAAY0B,GAAUqH,GAE1E,GAAoB,GAAhBC,GAAqBV,EAAS,IAAK,CAEtC,IAAIxH,EAASY,EAAS,GAAK2I,EAAgB3I,GAAU4I,EAAe5I,GACpE,GAAc,MAAVZ,EACH,OAAOA,EAET,OAAOyJ,EAAgB7I,GACjB,CACN,IAAIxE,EACJ,OAAQ0M,GACP,KAAK,IAAM,OAAO,KAClB,KAAK,IAAM,OAAOrL,EAClB,KAAK,IAAM,OAAO,EAClB,KAAK,IAAM,OAAO,EAClB,KAAK,IAEJ,OAAOiM,EAAQnC,EAAIrI,MACpB,KAAK,IAIJ,OAFA9C,EAAQyL,EAAS8B,UAAUzK,GAC3BA,GAAY,EACLwK,EAAQtN,GAChB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS+B,UAAU1K,GAC3BA,GAAY,EACLwK,EAAQtN,GAChB,KAAK,IAEJ,OAAOyN,EAAQtC,EAAIrI,MACpB,KAAK,IAIJ,OAFA9C,EAAQyL,EAAS8B,UAAUzK,GAC3BA,GAAY,EACL2K,EAAQzN,GAChB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS+B,UAAU1K,GAC3BA,GAAY,EACL2K,EAAQzN,GAChB,KAAK,IAEJ,GADAA,EAAQyL,EAASiC,WAAW5K,GACxB8I,EAAe9E,WAAa,EAAG,CAElC,IAAI6G,EAAarM,GAAyB,IAAhB6J,EAAIrI,KAAqB,EAAMqI,EAAIrI,EAAW,IAAM,GAE9E,OADAA,GAAY,GACH6K,EAAa3N,GAASA,EAAQ,EAAI,IAAO,KAAS,GAAK2N,EAGjE,OADA7K,GAAY,EACL9C,EACR,KAAK,IAGJ,OAFAA,EAAQyL,EAASmC,WAAW9K,GAC5BA,GAAY,EACL9C,EAER,KAAK,IACJ,OAAOmL,EAAIrI,KACZ,KAAK,IAGJ,OAFA9C,EAAQyL,EAAS8B,UAAUzK,GAC3BA,GAAY,EACL9C,EACR,KAAK,IAGJ,OAFAA,EAAQyL,EAAS+B,UAAU1K,GAC3BA,GAAY,EACL9C,EACR,KAAK,IACJ,OAAI4L,EAAeiC,eACO,kBAAlB1C,EAAIrI,KAAoD,gBAAlBqI,EAAIrI,KAAkD,cAAlBqI,EAAIrI,KAAgD,WAAlBqI,EAAIrI,KACpG,SAAlBqI,EAAIrI,MAA2BqI,EAAIrI,MAAe,KAAOqI,EAAIrI,MAAe,GAAKqI,EAAIrI,MACvF9C,EAAQyL,EAASqC,aAAahL,GAC9BA,GAAY,EACL9C,GAGR,KAAK,IACJ,OAAOyL,EAASsC,QAAQjL,KACzB,KAAK,IAGJ,OAFA9C,EAAQyL,EAASuC,SAASlL,GAC1BA,GAAY,EACL9C,EACR,KAAK,IAGJ,OAFAA,EAAQyL,EAASwC,SAASnL,GAC1BA,GAAY,EACL9C,EACR,KAAK,IAGJ,OAFAA,EAAQyL,EAASyC,YAAYpL,GAC7BA,GAAY,EACL9C,EAER,KAAK,IAGJ,GADAA,EAAQmL,EAAIrI,KACC,KAAT9C,EACH,OAAOmO,EAAiBhD,EAAIrI,MAE5B,GAAIiJ,EAAkB/L,GACrB,OAAO+L,EAAkB/L,GAAO,CAACmL,EAAIrI,OAErC,MAAM,IAAI2B,MAAM,qBAAuBzE,GAE1C,KAAK,IAEJ,OAAOyN,EAAQ,GAChB,KAAK,IAEJ,OAAOA,EAAQ,GAChB,KAAK,IAEJ,OAAOA,EAAQ,GAChB,KAAK,IAEJ,OAAOA,EAAQ,IAChB,KAAK,IAGJ,OADAzN,EAAQmL,EAAIrI,KACRgJ,GAAgBhJ,EACZ0I,EAAUrF,MAAMrD,EAAW+I,GAAiB/I,GAAY9C,GAAS6L,GAElEuC,EAAYpO,GACpB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS8B,UAAUzK,GAC3BA,GAAY,EACRgJ,GAAgBhJ,EACZ0I,EAAUrF,MAAMrD,EAAW+I,GAAiB/I,GAAY9C,GAAS6L,GAElEwC,EAAarO,GACrB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS+B,UAAU1K,GAC3BA,GAAY,EACRgJ,GAAgBhJ,EACZ0I,EAAUrF,MAAMrD,EAAW+I,GAAiB/I,GAAY9C,GAAS6L,GAElEyC,EAAatO,GACrB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS8B,UAAUzK,GAC3BA,GAAY,EACLyL,EAAUvO,GAClB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS+B,UAAU1K,GAC3BA,GAAY,EACLyL,EAAUvO,GAClB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS8B,UAAUzK,GAC3BA,GAAY,EACL0L,EAAQxO,GAChB,KAAK,IAIJ,OAFAA,EAAQyL,EAAS+B,UAAU1K,GAC3BA,GAAY,EACL0L,EAAQxO,GAChB,QACC,GAAI0M,GAAS,IACZ,OAAOA,EAAQ,IAChB,QAAcR,IAAVQ,EAAqB,CACxB,IAAIvK,EAAQ,IAAIsC,MAAM,sCAEtB,MADAtC,EAAMsM,YAAa,EACbtM,EAEP,MAAM,IAAIsC,MAAM,6BAA+BiI,KAvOnDnO,EAAQyC,QAAUzC,EAAQwC,QAAUA,EACpCxC,EAAQ+N,KAAOA,EACf/N,EAAQmQ,YAAc,IACd5L,EAyOR,MAAM6L,EAAY,4BAClB,SAAS/B,EAAsBD,GAC9B,SAASiC,IAER,GAAIA,EAAWC,QAAU,EAExB,OADAtL,KAAK+I,KAAO,IAAKwC,SAAS,IAAK,6BAA+BnC,EAAUO,IAAI5M,GAAOqO,EAAUI,KAAKzO,GAAOA,EAAM,OAAU,IAAM0O,KAAKC,UAAU3O,GAAO,SAAU4O,KAAK,KAAO,KAA/J,CAAsK5C,GAC3K/I,KAAK+I,OAEb,IAAI7L,EAAS,GACb,IAAK,IAAI1B,EAAI,EAAGC,EAAI2N,EAAUnI,OAAQzF,EAAIC,EAAGD,IAAK,CAEjD0B,EADUkM,EAAU5N,IACNuN,IAEf,OAAO7L,EAGR,OADAmO,EAAWC,MAAQ,EACZD,EAGR,IAAIvB,EAAkB8B,EAClBf,EAAce,EACdd,EAAec,EACfb,EAAea,EAqCnB,SAASA,EAAa3K,GACrB,IAAIkD,EACJ,GAAIlD,EAAS,KACRkD,EAASyF,EAAgB3I,IAC5B,OAAOkD,EAET,GAAIlD,EAAS,IAAM0G,EAClB,OAAOA,EAAQ/J,OAAOgK,EAAIpH,SAASjB,EAAUA,GAAY0B,IAC1D,MAAMoE,EAAM9F,EAAW0B,EACjB4K,EAAQ,GAEd,IADA1H,EAAS,GACF5E,EAAW8F,GAAK,CACtB,MAAMyG,EAAQlE,EAAIrI,KAClB,GAAuB,IAAV,IAARuM,GAEJD,EAAMjI,KAAKkI,QACL,GAAuB,MAAV,IAARA,GAAwB,CAEnC,MAAMC,EAA0B,GAAlBnE,EAAIrI,KAClBsM,EAAMjI,MAAe,GAARkI,IAAiB,EAAKC,QAC7B,GAAuB,MAAV,IAARD,GAAwB,CAEnC,MAAMC,EAA0B,GAAlBnE,EAAIrI,KACZyM,EAA0B,GAAlBpE,EAAIrI,KAClBsM,EAAMjI,MAAe,GAARkI,IAAiB,GAAOC,GAAS,EAAKC,QAC7C,GAAuB,MAAV,IAARF,GAAwB,CAKnC,IAAIG,GAAiB,EAARH,IAAiB,IAHE,GAAlBlE,EAAIrI,OAG8B,IAFhB,GAAlBqI,EAAIrI,OAEgD,EADlC,GAAlBqI,EAAIrI,KAEd0M,EAAO,QACVA,GAAQ,MACRJ,EAAMjI,KAAOqI,IAAS,GAAM,KAAS,OACrCA,EAAO,MAAiB,KAAPA,GAElBJ,EAAMjI,KAAKqI,QAEXJ,EAAMjI,KAAKkI,GAGRD,EAAM5K,QAAU,OACnBkD,GAAU+H,EAAa1C,MAAM2C,OAAQN,GACrCA,EAAM5K,OAAS,GAQjB,OAJI4K,EAAM5K,OAAS,IAClBkD,GAAU+H,EAAa1C,MAAM2C,OAAQN,IAG/B1H,EAGR,SAAS6G,EAAU/J,GAClB,IAAI8F,EAAQ,IAAI/C,MAAM/C,GACtB,IAAK,IAAIzF,EAAI,EAAGA,EAAIyF,EAAQzF,IAC3BuL,EAAMvL,GAAKuN,IAEZ,OAAOhC,EAGR,SAASkE,EAAQhK,GAChB,GAAIoH,EAAeK,cAAe,CACjC,IAAIxL,EAAS,GACb,IAAK,IAAI1B,EAAI,EAAGA,EAAIyF,EAAQzF,IAC3B0B,EAAOwM,KAAaX,IAErB,OAAO7L,EACD,CACN,IAAIyM,EAAM,IAAIrI,IACd,IAAK,IAAI9F,EAAI,EAAGA,EAAIyF,EAAQzF,IAC3BmO,EAAI9F,IAAIkF,IAAQA,KAEjB,OAAOY,GA7GT3O,EAAQoR,aAAgBC,IAKvB,SAASC,EAAWC,GACnB,OAAO,SAAoBtL,GAC1B,IAAIZ,EAAS8H,EAAQC,KACrB,GAAc,MAAV/H,EAAgB,CACnB,IAAImM,EAAaH,EAAe9M,EAAWgN,EAAc1E,EAAQD,GACjE,GAAyB,iBAAd4E,EACVnM,EAASmM,EACTrE,EAAUJ,OAMV,GAJAI,EAAUqE,EACVpE,EAAiB,EACjBG,EAAe,EACflI,EAAS8H,EAAQ,QACFQ,IAAXtI,EACH,MAAM,IAAIa,MAAM,4BAGnB,IAAIuL,EAAkBpM,EAAOY,OAC7B,OAAIwL,GAAmBxL,GACtB1B,GAAY0B,EACLZ,IAER4H,EAAY5H,EACZiI,EAAiB/I,EACjBgJ,EAAehJ,EAAWkN,EAC1BlN,GAAY0B,EACLZ,EAAOuC,MAAM,EAAG3B,KA9BzB6I,EAAkBwC,EAAW,GAC7BzB,EAAcyB,EAAW,GACzBxB,EAAewB,EAAW,GAC1BvB,EAAeuB,EAAW,IA6G3B,IAAIJ,EAAeC,OAAOD,aAC1B,SAASrC,EAAe5I,GACvB,IAAIvB,EAAQH,EACRmN,EAAQ,IAAI1I,MAAM/C,GACtB,IAAK,IAAIzF,EAAI,EAAGA,EAAIyF,EAAQzF,IAAK,CAChC,MAAMmR,EAAO/E,EAAIrI,KACjB,IAAY,IAAPoN,GAAe,EAEf,YADJpN,EAAWG,GAGRgN,EAAMlR,GAAKmR,EAEZ,OAAOT,EAAa1C,MAAM2C,OAAQO,GAEvC,SAAS9C,EAAgB3I,GACxB,GAAIA,EAAS,EAAG,CACf,GAAIA,EAAS,EAAG,CACf,GAAe,IAAXA,EACH,MAAO,GACH,CACJ,IAAIoB,EAAIuF,EAAIrI,KACZ,OAAS,IAAJ8C,GAAY,OAChB9C,GAAY,GAGN2M,EAAa7J,IAEf,CACN,IAAIA,EAAIuF,EAAIrI,KACR+C,EAAIsF,EAAIrI,KACZ,IAAS,IAAJ8C,GAAY,IAAU,IAAJC,GAAY,EAElC,YADA/C,GAAY,GAGb,GAAI0B,EAAS,EACZ,OAAOiL,EAAa7J,EAAGC,GACxB,IAAIzG,EAAI+L,EAAIrI,KACZ,OAAS,IAAJ1D,GAAY,OAChB0D,GAAY,GAGN2M,EAAa7J,EAAGC,EAAGzG,IAErB,CACN,IAAIwG,EAAIuF,EAAIrI,KACR+C,EAAIsF,EAAIrI,KACR1D,EAAI+L,EAAIrI,KACRzD,EAAI8L,EAAIrI,KACZ,IAAS,IAAJ8C,GAAY,IAAU,IAAJC,GAAY,IAAU,IAAJzG,GAAY,IAAU,IAAJC,GAAY,EAEtE,YADAyD,GAAY,GAGb,GAAI0B,EAAS,EAAG,CACf,GAAe,IAAXA,EACH,OAAOiL,EAAa7J,EAAGC,EAAGzG,EAAGC,GACzB,CACJ,IAAI8Q,EAAIhF,EAAIrI,KACZ,OAAS,IAAJqN,GAAY,OAChBrN,GAAY,GAGN2M,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,IAE3B,GAAI3L,EAAS,EAAG,CACtB,IAAI2L,EAAIhF,EAAIrI,KACRsN,EAAIjF,EAAIrI,KACZ,IAAS,IAAJqN,GAAY,IAAU,IAAJC,GAAY,EAElC,YADAtN,GAAY,GAGb,GAAI0B,EAAS,EACZ,OAAOiL,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,GACpC,IAAIC,EAAIlF,EAAIrI,KACZ,OAAS,IAAJuN,GAAY,OAChBvN,GAAY,GAGN2M,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,GAChC,CACN,IAAIF,EAAIhF,EAAIrI,KACRsN,EAAIjF,EAAIrI,KACRuN,EAAIlF,EAAIrI,KACRwN,EAAInF,EAAIrI,KACZ,IAAS,IAAJqN,GAAY,IAAU,IAAJC,GAAY,IAAU,IAAJC,GAAY,IAAU,IAAJC,GAAY,EAEtE,YADAxN,GAAY,GAGb,GAAI0B,EAAS,GAAI,CAChB,GAAe,IAAXA,EACH,OAAOiL,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,GACrC,CACJ,IAAIvR,EAAIoM,EAAIrI,KACZ,OAAS,IAAJ/D,GAAY,OAChB+D,GAAY,GAGN2M,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,EAAGvR,IAEvC,GAAIyF,EAAS,GAAI,CACvB,IAAIzF,EAAIoM,EAAIrI,KACRyN,EAAIpF,EAAIrI,KACZ,IAAS,IAAJ/D,GAAY,IAAU,IAAJwR,GAAY,EAElC,YADAzN,GAAY,IAGb,GAAI0B,EAAS,GACZ,OAAOiL,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,EAAGvR,EAAGwR,GAChD,IAAIC,EAAIrF,EAAIrI,KACZ,OAAS,IAAJ0N,GAAY,OAChB1N,GAAY,IAGN2M,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,EAAGvR,EAAGwR,EAAGC,GAC5C,CACN,IAAIzR,EAAIoM,EAAIrI,KACRyN,EAAIpF,EAAIrI,KACR0N,EAAIrF,EAAIrI,KACR9D,EAAImM,EAAIrI,KACZ,IAAS,IAAJ/D,GAAY,IAAU,IAAJwR,GAAY,IAAU,IAAJC,GAAY,IAAU,IAAJxR,GAAY,EAEtE,YADA8D,GAAY,IAGb,GAAI0B,EAAS,GAAI,CAChB,GAAe,KAAXA,EACH,OAAOiL,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,EAAGvR,EAAGwR,EAAGC,EAAGxR,GACjD,CACJ,IAAIG,EAAIgM,EAAIrI,KACZ,OAAS,IAAJ3D,GAAY,OAChB2D,GAAY,IAGN2M,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,EAAGvR,EAAGwR,EAAGC,EAAGxR,EAAGG,IAEnD,CACN,IAAIA,EAAIgM,EAAIrI,KACRtC,EAAI2K,EAAIrI,KACZ,IAAS,IAAJ3D,GAAY,IAAU,IAAJqB,GAAY,EAElC,YADAsC,GAAY,IAGb,GAAI0B,EAAS,GACZ,OAAOiL,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,EAAGvR,EAAGwR,EAAGC,EAAGxR,EAAGG,EAAGqB,GAC5D,IAAIhB,EAAI2L,EAAIrI,KACZ,OAAS,IAAJtD,GAAY,OAChBsD,GAAY,IAGN2M,EAAa7J,EAAGC,EAAGzG,EAAGC,EAAG8Q,EAAGC,EAAGC,EAAGC,EAAGvR,EAAGwR,EAAGC,EAAGxR,EAAGG,EAAGqB,EAAGhB,OAOnE,SAAS8N,EAAQ9I,GAChB,OAAOoH,EAAe6E,YAErBjO,WAAW7B,UAAUwF,MAAMjH,KAAKiM,EAAKrI,EAAUA,GAAY0B,GAC3D2G,EAAIpH,SAASjB,EAAUA,GAAY0B,GAErC,SAASiJ,EAAQjJ,GAChB,IAAI4B,EAAO+E,EAAIrI,KACf,GAAIiJ,EAAkB3F,GACrB,OAAO2F,EAAkB3F,GAAM+E,EAAIpH,SAASjB,EAAUA,GAAY0B,IAGlE,MAAM,IAAIC,MAAM,0BAA4B2B,GAG9C,IAAIsK,EAAW,IAAInJ,MAAM,MACzB,SAAS0F,IACR,IAAIzI,EAAS2G,EAAIrI,KACjB,KAAI0B,GAAU,KAAQA,EAAS,KAS9B,OADA1B,IACOwJ,IANP,GADA9H,GAAkB,IACdsH,GAAgBhJ,EACnB,OAAO0I,EAAUrF,MAAMrD,EAAW+I,GAAiB/I,GAAY0B,GAAUqH,GACrE,KAAsB,GAAhBC,GAAqBV,EAAS,KACxC,OAAOiC,EAAgB7I,GAKzB,IAIImM,EAJArQ,EAAuG,MAA/FkE,GAAU,GAAMA,EAAS,EAAIiH,EAAS8B,UAAUzK,GAAY0B,EAAS,EAAI2G,EAAIrI,GAAY,IACjG8N,EAAQF,EAASpQ,GACjBuQ,EAAgB/N,EAChB8F,EAAM9F,EAAW0B,EAAS,EAE1BzF,EAAI,EACR,GAAI6R,GAASA,EAAMX,OAASzL,EAAQ,CACnC,KAAOqM,EAAgBjI,GAAK,CAE3B,GADA+H,EAAQlF,EAAS+B,UAAUqD,GACvBF,GAASC,EAAM7R,KAAM,CACxB8R,EAAgB,WAChB,MAEDA,GAAiB,EAGlB,IADAjI,GAAO,EACAiI,EAAgBjI,GAEtB,GADA+H,EAAQxF,EAAI0F,KACRF,GAASC,EAAM7R,KAAM,CACxB8R,EAAgB,WAChB,MAGF,GAAIA,IAAkBjI,EAErB,OADA9F,EAAW+N,EACJD,EAAMhN,OAEdgF,GAAO,EACPiI,EAAgB/N,EAKjB,IAHA8N,EAAQ,GACRF,EAASpQ,GAAOsQ,EAChBA,EAAMX,MAAQzL,EACPqM,EAAgBjI,GACtB+H,EAAQlF,EAAS+B,UAAUqD,GAC3BD,EAAMzJ,KAAKwJ,GACXE,GAAiB,EAGlB,IADAjI,GAAO,EACAiI,EAAgBjI,GACtB+H,EAAQxF,EAAI0F,KACZD,EAAMzJ,KAAKwJ,GAGZ,IAAI/M,EAASY,EAAS,GAAK2I,EAAgB3I,GAAU4I,EAAe5I,GACpE,OACQoM,EAAMhN,OADA,MAAVA,EACmBA,EACDyJ,EAAgB7I,GAIvC,MAAM2J,EAAoBpI,IACzB,IAAI4G,EAAYpB,EAAuB,GAALxF,GAAauG,IAE/C,OADAK,EAAUL,KAAOM,EAAsBD,GAChCA,EAAUL,QAElB,IAAIwE,EAAwB,iBAAVnS,OAAqBA,OAASoS,EAChDhF,EAAkB,GAAMiF,MAExBjF,EAAkB,KAAQ,KACzB,IAAIiF,EAAO1E,IACX,OAAQwE,EAAKE,EAAK,KAAOvM,OAAOuM,EAAK,KAGtCjF,EAAkB,KAASiF,IAE1B,IAAIjL,EAAK0F,EAAS+B,UAAU1K,EAAW,GAClCO,IACJA,EAAe,IAAIwB,KACpB,IACIlC,EADA+J,EAAQvB,EAAIrI,GAKfH,EADG+J,GAAS,KAAQA,EAAQ,KAAiB,KAATA,GAA0B,KAATA,EAC5C,GAEA,GAEV,IAAIuE,EAAW,CAAEtO,UACjBU,EAAa+D,IAAIrB,EAAIkL,GACrB,IAAIC,EAAmB5E,IACvB,OAAI2E,EAASE,KACL1R,OAAOwL,OAAOtI,EAAQuO,IAC9BD,EAAStO,OAASuO,EACXA,IAGRnF,EAAkB,KAASiF,IAE1B,IAAIjL,EAAK0F,EAAS+B,UAAU1K,EAAW,GACnCmO,EAAW5N,EAAazD,IAAImG,GAEhC,OADAkL,EAASE,MAAO,EACTF,EAAStO,QAGjBoJ,EAAkB,KAAQ,IAAM,IAAIpC,IAAI2C,KAExC,MAAM/K,EAAc,CAAC,OAAO,QAAQ,eAAe,QAAQ,SAAS,QAAQ,SAAS,UAAU,UAAU,WAAW,aAAa2L,IAAI9G,GAAQA,EAAO,SAiCpJ,SAASgG,EAAUgF,GAClB,IAAIC,EAAcjG,EACdkG,EAAgBxO,EAChByO,EAAsB5F,EACtB6F,EAAsB3F,EACtB4F,EAAoB3F,EACpB4F,EAAiBlG,EACjBmG,EAAejG,EACfkG,EAAoBvO,EAEpBwO,EAAW,IAAIrP,WAAW2I,EAAIhF,MAAM,EAAGiF,IACvC0G,EAAkBvG,EAClBwG,EAAanG,EACb5L,EAAQoR,IAaZ,OAZAhG,EAASiG,EACTvO,EAAWwO,EACX3F,EAAiB4F,EACjB1F,EAAiB2F,EACjB1F,EAAe2F,EACfjG,EAAYkG,EACZhG,EAAUiG,EACVtO,EAAeuO,EACfzG,EAAM0G,EACNtG,EAAoBuG,EACpBlG,EAAiBmG,EACjBtG,EAAW,IAAI/G,SAASyG,EAAIxG,OAAQwG,EAAI/B,WAAY+B,EAAI9B,YACjDrJ,EAGR,SAASqM,IACRlB,EAAM,KACN9H,EAAe,KACfkI,EAAoB,KA/DrBQ,EAAkB,KAASiF,IAC1B,IAAIgB,EAAWhB,EAAK,GAChBiB,EAAiB1Q,EAAYyQ,GACjC,IAAKC,EACJ,MAAM,IAAIxN,MAAM,uCAAyCuN,GAE1D,OAAO,IAAIlB,EAAKmB,GAAgBzP,WAAW7B,UAAUwF,MAAMjH,KAAK8R,EAAM,GAAGrM,SAE1EoH,EAAkB,KAAQ,KACzB,IAAIiF,EAAO1E,IACX,OAAO,IAAI1C,OAAOoH,EAAK,GAAIA,EAAK,KAGjCjF,EAAkB,KAASiF,IAE1B,GAAmB,GAAfA,EAAKxM,OACR,OAAO,IAAIkF,KAA0E,KAA1D,SAAVsH,EAAK,IAAkBA,EAAK,IAAM,KAAOA,EAAK,IAAM,GAAKA,EAAK,KAC3E,GAAmB,GAAfA,EAAKxM,OACb,OAAO,IAAIkF,OACRsH,EAAK,IAAM,KAAOA,EAAK,IAAM,KAAOA,EAAK,IAAM,IAAMA,EAAK,IAAM,IAAM,IAC6B,KAAlF,YAAP,EAAVA,EAAK,IAAoC,SAAVA,EAAK,IAAkBA,EAAK,IAAM,KAAOA,EAAK,IAAM,GAAKA,EAAK,KAC5F,GAAmB,IAAfA,EAAKxM,OACb,OAAO,IAAIkF,OACRsH,EAAK,IAAM,KAAOA,EAAK,IAAM,KAAOA,EAAK,IAAM,GAAKA,EAAK,IAAM,IACoG,MAAxJ,IAAVA,EAAK,IAAc,gBAAkB,GAAe,cAAVA,EAAK,GAA+B,WAAVA,EAAK,GAA6B,SAAVA,EAAK,IAAkBA,EAAK,IAAM,KAAOA,EAAK,KAAO,GAAKA,EAAK,MAE/J,MAAM,IAAIvM,MAAM,6BAiClBlG,EAAQ8N,YAAcA,EAOtB9N,EAAQ6C,aAAe,SAASuG,GAC/BoE,EAAkBpE,EAAUvB,MAAQuB,EAAU1G,QAG/C,IAAIK,EAAS,IAAIiG,MAAM,KACvB,IAAK,IAAIxI,EAAI,EAAGA,EAAI,IAAKA,IACxBuC,EAAOvC,KAAO,KAAO+J,KAAKuB,MAAM,MAAY,OAAJtL,IAEzCR,EAAQ+C,OAASA,EACjB/C,EAAQgD,YAAcA,EACtBhD,EAAQ8J,YAAa,EACrB9J,EAAQ0N,eAAgB,EACxB1N,EAAQ8C,GAAKA,EACb9C,EAAQiD,OAASA,EACjB,IAAIiL,EAAiB,IAAI1L,EAAQ,CAAEsH,YAAY,IAC/C9J,EAAQ0C,OAASwL,EAAexL,OAChC1C,EAAQ2C,eAAiBuL,EAAevL,eACxC3C,EAAQ4C,OAASsL,EAAexL,OAChC1C,EAAQkD,gBAAkB,CACzByQ,MAAO,EACPC,OAAQ,EACRC,cAAe,EACfC,YAAa,K,iCC91Bd9T,EAAQmD,MAAQ,EAAQ,GAAUA,MAClCnD,EAAQoD,QAAUpD,EAAQmD,MAC1BnD,EAAQwC,QAAU,EAAQ,GAAYA,QACtCxC,EAAQyC,QAAUzC,EAAQwC,QAC1BxC,EAAQ6C,aAAe,EAAQ,GAAUA,aACzC,IAAI6C,EAAQ,IAAI1F,EAAQmD,MAAM,CAAE2G,YAAY,IAC5C9J,EAAQ0C,OAASgD,EAAMhD,OACvB1C,EAAQ2C,eAAiB+C,EAAM/C,eAC/B3C,EAAQqD,KAAOqC,EAAMrC,KACrBrD,EAAQ4C,OAAS8C,EAAMhD,OACvB1C,EAAQsD,OAASoC,EAAMrC,KACvBrD,EAAQkD,gBAAkB,EAAQ,GAAYA,gBAC9ChC,OAAOwL,OAAO1M,EAAS,CACtB4T,OAAO,EACPC,cAAe,EACfC,YAAa,K,cCfd,IAAIhC,EAGJA,EAAI,WACH,OAAO9M,KADJ,GAIJ,IAEC8M,EAAIA,GAAK,IAAIvB,SAAS,cAAb,GACR,MAAOqB,GAEc,iBAAXxR,SAAqB0R,EAAI1R,QAOrCH,EAAOD,QAAU8R","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"msgpackr\"] = factory();\n\telse\n\t\troot[\"msgpackr\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","import unpackModule from './unpack.js'\r\nexport const { Unpackr, Decoder, unpack, unpackMultiple, decode, addExtension, C1, mult10, typedArrays, C1Type, FLOAT32_OPTIONS } = unpackModule","import packModule from './pack.js'\r\nexport const { Packr, Encoder, pack, encode, addExtension, FLOAT32_OPTIONS } = packModule","\"use strict\"\r\nlet unpackModule = require('./unpack')\r\nlet Unpackr = unpackModule.Unpackr\r\nlet mult10 = unpackModule.mult10\r\nlet C1Type = unpackModule.C1Type\r\nconst typedArrays = unpackModule.typedArrays\r\nlet textEncoder\r\ntry {\r\n\ttextEncoder = new TextEncoder()\r\n} catch (error) {}\r\nlet extensions, extensionClasses\r\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\r\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\r\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\r\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\r\nlet target\r\nlet targetView\r\nlet position = 0\r\nlet safeEnd\r\nconst RECORD_SYMBOL = Symbol('record-id')\r\nclass Packr extends Unpackr {\r\n\tconstructor(options) {\r\n\t\tsuper(options)\r\n\t\tthis.offset = 0\r\n\t\tlet typeBuffer\r\n\t\tlet start\r\n\t\tlet sharedStructures\r\n\t\tlet hasSharedUpdate\r\n\t\tlet structures\r\n\t\tlet referenceMap\r\n\t\tlet lastSharedStructuresLength = 0\r\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\r\n\t\t\treturn target.utf8Write(string, position, maxBytes)\r\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\r\n\t\t\tfunction(string, position) {\r\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\r\n\t\t\t} : false\r\n\r\n\t\tlet packr = this\r\n\t\tlet maxSharedStructures = 32\r\n\t\tlet isSequential = options && options.sequential\r\n\t\tif (isSequential) {\r\n\t\t\tmaxSharedStructures = 0\r\n\t\t\tthis.structures = []\r\n\t\t}\r\n\t\tlet recordIdsToRemove = []\r\n\t\tlet transitionsCount = 0\r\n\t\tlet serializationsSinceTransitionRebuild = 0\r\n\t\tif (this.structures && this.structures.length > maxSharedStructures) {\r\n\t\t\tthrow new Error('Too many shared structures')\r\n\t\t}\r\n\r\n\t\tthis.pack = this.encode = function(value) {\r\n\t\t\tif (!target) {\r\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\r\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\r\n\t\t\t\tposition = 0\r\n\t\t\t}\r\n\t\t\tsafeEnd = target.length - 10\r\n\t\t\tif (safeEnd - position < 0x800) {\r\n\t\t\t\t// don't start too close to the end, \r\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\r\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\r\n\t\t\t\tsafeEnd = target.length - 10\r\n\t\t\t\tposition = 0\r\n\t\t\t}\r\n\t\t\tstart = position\r\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\r\n\t\t\tsharedStructures = packr.structures\r\n\t\t\tif (sharedStructures) {\r\n\t\t\t\tif (sharedStructures.uninitialized)\r\n\t\t\t\t\tpackr.structures = sharedStructures = packr.getStructures()\r\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\r\n\t\t\t\tif (sharedStructuresLength >  maxSharedStructures && !isSequential)\r\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\r\n\t\t\t\tif (!sharedStructures.transitions) {\r\n\t\t\t\t\t// rebuild our structure transitions\r\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\r\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\r\n\t\t\t\t\t\tlet keys = sharedStructures[i]\r\n\t\t\t\t\t\tif (!keys)\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\r\n\t\t\t\t\t\tfor (let i =0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\tlet key = keys[i]\r\n\t\t\t\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\t\t\t\tif (!nextTransition) {\r\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttransition = nextTransition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastSharedStructuresLength = sharedStructures.length\r\n\t\t\t\t}\r\n\t\t\t\tif (!isSequential)\r\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength + 0x40\r\n\t\t\t}\r\n\t\t\tif (hasSharedUpdate)\r\n\t\t\t\thasSharedUpdate = false\r\n\t\t\tstructures = sharedStructures || []\r\n\t\t\ttry {\r\n\t\t\t\tpack(value)\r\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\r\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\r\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 6\r\n\t\t\t\t\tif (position > safeEnd)\r\n\t\t\t\t\t\tmakeRoom(position)\r\n\t\t\t\t\tpackr.offset = position\r\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\r\n\t\t\t\t\treferenceMap = null\r\n\t\t\t\t\treturn serialized\r\n\t\t\t\t}\r\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\r\n\t\t\t} finally {\r\n\t\t\t\tif (sharedStructures) {\r\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\r\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\r\n\t\t\t\t\tif (transitionsCount > 10000) {\r\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\r\n\t\t\t\t\t\tsharedStructures.transitions = null\r\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\r\n\t\t\t\t\t\ttransitionsCount = 0\r\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\r\n\t\t\t\t\t\t\trecordIdsToRemove = []\r\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\r\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\r\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trecordIdsToRemove = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\r\n\t\t\t\t\t\tif (packr.structures.length > maxSharedStructures) {\r\n\t\t\t\t\t\t\tpackr.structures = packr.structures.slice(0, maxSharedStructures)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (packr.saveStructures(packr.structures, lastSharedStructuresLength) === false) {\r\n\t\t\t\t\t\t\t// get updated structures and try again if the update failed\r\n\t\t\t\t\t\t\tpackr.structures = packr.getStructures() || []\r\n\t\t\t\t\t\t\treturn packr.pack(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlastSharedStructuresLength = packr.structures.length\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst pack = (value) => {\r\n\t\t\tif (position > safeEnd)\r\n\t\t\t\ttarget = makeRoom(position)\r\n\r\n\t\t\tvar type = typeof value\r\n\t\t\tvar length\r\n\t\t\tif (type === 'string') {\r\n\t\t\t\tlet strLength = value.length\r\n\t\t\t\tlet headerSize\r\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\r\n\t\t\t\tif (strLength < 0x20) {\r\n\t\t\t\t\theaderSize = 1\r\n\t\t\t\t} else if (strLength < 0x100) {\r\n\t\t\t\t\theaderSize = 2\r\n\t\t\t\t} else if (strLength < 0x10000) {\r\n\t\t\t\t\theaderSize = 3\r\n\t\t\t\t} else {\r\n\t\t\t\t\theaderSize = 5\r\n\t\t\t\t}\r\n\t\t\t\tlet maxBytes = strLength * 3\r\n\t\t\t\tif (position + maxBytes > safeEnd)\r\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\r\n\r\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\r\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\r\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\r\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\r\n\t\t\t\t\t\tif (c1 < 0x80) {\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\r\n\t\t\t\t\t\t} else if (c1 < 0x800) {\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\r\n\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\r\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\r\n\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlength = strPosition - position - headerSize\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (length < 0x20) {\r\n\t\t\t\t\ttarget[position++] = 0xa0 | length\r\n\t\t\t\t} else if (length < 0x100) {\r\n\t\t\t\t\tif (headerSize < 2) {\r\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0xd9\r\n\t\t\t\t\ttarget[position++] = length\r\n\t\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\t\tif (headerSize < 3) {\r\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0xda\r\n\t\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (headerSize < 5) {\r\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0xdb\r\n\t\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\t\tposition += 4\r\n\t\t\t\t}\r\n\t\t\t\tposition += length\r\n\t\t\t} else if (type === 'number') {\r\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\r\n\t\t\t\t\t// positive uint\r\n\t\t\t\t\tif (value < 0x40) {\r\n\t\t\t\t\t\ttarget[position++] = value\r\n\t\t\t\t\t} else if (value < 0x100) {\r\n\t\t\t\t\t\ttarget[position++] = 0xcc\r\n\t\t\t\t\t\ttarget[position++] = value\r\n\t\t\t\t\t} else if (value < 0x10000) {\r\n\t\t\t\t\t\ttarget[position++] = 0xcd\r\n\t\t\t\t\t\ttarget[position++] = value >> 8\r\n\t\t\t\t\t\ttarget[position++] = value & 0xff\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget[position++] = 0xce\r\n\t\t\t\t\t\ttargetView.setUint32(position, value)\r\n\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\r\n\t\t\t\t\tif (value >= -0x20) {\r\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\r\n\t\t\t\t\t} else if (value >= -0x80) {\r\n\t\t\t\t\t\ttarget[position++] = 0xd0\r\n\t\t\t\t\t\ttarget[position++] = value + 0x100\r\n\t\t\t\t\t} else if (value >= -0x8000) {\r\n\t\t\t\t\t\ttarget[position++] = 0xd1\r\n\t\t\t\t\t\ttargetView.setInt16(position, value)\r\n\t\t\t\t\t\tposition += 2\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget[position++] = 0xd2\r\n\t\t\t\t\t\ttargetView.setInt32(position, value)\r\n\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet useFloat32\r\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\r\n\t\t\t\t\t\ttarget[position++] = 0xca\r\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\r\n\t\t\t\t\t\tlet xShifted\r\n\t\t\t\t\t\tif (useFloat32 < 4 ||\r\n\t\t\t\t\t\t\t// this checks for  rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\r\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0xcb\r\n\t\t\t\t\ttargetView.setFloat64(position, value)\r\n\t\t\t\t\tposition += 8\r\n\t\t\t\t}\r\n\t\t\t} else if (type === 'object') {\r\n\t\t\t\tif (!value)\r\n\t\t\t\t\ttarget[position++] = 0xc0\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (referenceMap) {\r\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\r\n\t\t\t\t\t\tif (referee) {\r\n\t\t\t\t\t\t\tif (!referee.id) {\r\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\r\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\r\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\r\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t} else \r\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet constructor = value.constructor\r\n\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\twriteObject(value, true)\r\n\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\tlength = value.length\r\n\t\t\t\t\t\tif (length < 0x10) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0x90 | length\r\n\t\t\t\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xdc\r\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xdd\r\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\t\t\t\tpack(value[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (constructor === Map) {\r\n\t\t\t\t\t\tlength = value.size\r\n\t\t\t\t\t\tif (length < 0x10) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\r\n\t\t\t\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xde\r\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xdf\r\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\r\n\t\t\t\t\t\t\tpack(key)\r\n\t\t\t\t\t\t\tpack(entryValue)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\t\r\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\r\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\r\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\r\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\r\n\t\t\t\t\t\t\t\tlet currentTarget = target\r\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\r\n\t\t\t\t\t\t\t\tlet currentPosition = position\r\n\t\t\t\t\t\t\t\ttarget = null\r\n\t\t\t\t\t\t\t\tlet result\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\r\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\r\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\r\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\r\n\t\t\t\t\t\t\t\t\t\tposition += size\r\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\r\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\r\n\t\t\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, pack)\r\n\t\t\t\t\t\t\t\t} finally {\r\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\r\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\r\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\r\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\r\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\r\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// no extension found, write as object\r\n\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (type === 'boolean') {\r\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\r\n\t\t\t} else if (type === 'bigint') {\r\n\t\t\t\tif (value < (1n<<63n) && value >= -(1n<<63n)) {\r\n\t\t\t\t\t// use a signed int as long as it fits\r\n\t\t\t\t\ttarget[position++] = 0xd3\r\n\t\t\t\t\ttargetView.setBigInt64(position, value)\r\n\t\t\t\t} else if (value < (1n<<64n) && value > 0) {\r\n\t\t\t\t\t// if we can fit an unsigned int, use that\r\n\t\t\t\t\ttarget[position++] = 0xcf\r\n\t\t\t\t\ttargetView.setBigUint64(position, value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// overflow\r\n\t\t\t\t\tif (this.largeBigIntToFloat) {\r\n\t\t\t\t\t\ttarget[position++] = 0xcb\r\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tposition += 8\r\n\t\t\t} else if (type === 'undefined') {\r\n\t\t\t\t//target[position++] = 0xc1 // this is the \"never-used\" byte\r\n\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\r\n\t\t\t\ttarget[position++] = 0\r\n\t\t\t\ttarget[position++] = 0\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Unknown type ' + type)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\r\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\r\n\t\t\tlet keys = Object.keys(object)\r\n\t\t\tlet length = keys.length\r\n\t\t\tif (length < 0x10) {\r\n\t\t\t\ttarget[position++] = 0x80 | length\r\n\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\ttarget[position++] = 0xde\r\n\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t} else {\r\n\t\t\t\ttarget[position++] = 0xdf\r\n\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\tposition += 4\r\n\t\t\t}\r\n\t\t\tlet key\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tpack(key = keys[i])\r\n\t\t\t\tpack(object[key])\r\n\t\t\t}\r\n\t\t} :\r\n\t\t(object, safePrototype) => {\r\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\r\n\t\t\tlet objectOffset = position - start\r\n\t\t\tposition += 2\r\n\t\t\tlet size = 0\r\n\t\t\tfor (let key in object) {\r\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\r\n\t\t\t\t\tpack(key)\r\n\t\t\t\t\tpack(object[key])\r\n\t\t\t\t\tsize++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttarget[objectOffset++ + start] = size >> 8\r\n\t\t\ttarget[objectOffset + start] = size & 0xff\r\n\t\t} :\r\n\r\n\t/*\tsharedStructures ?  // For highly stable structures, using for-in can a little bit faster\r\n\t\t(object, safePrototype) => {\r\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\r\n\t\t\tlet objectOffset = position++ - start\r\n\t\t\tlet wroteKeys\r\n\t\t\tfor (let key in object) {\r\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\r\n\t\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\t\tif (!nextTransition) {\r\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\r\n\t\t\t\t\t\tnextTransition.__keys__ = (transition.__keys__ || []).concat([key])\r\n\t\t\t\t\t\t/*let keys = Object.keys(object)\r\n\t\t\t\t\t\tif \r\n\t\t\t\t\t\tlet size = 0\r\n\t\t\t\t\t\tlet startBranch = transition.__keys__ ? transition.__keys__.length : 0\r\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i++) {\r\n\t\t\t\t\t\t\tlet key = keys[i]\r\n\t\t\t\t\t\t\tsize += key.length << 2\r\n\t\t\t\t\t\t\tif (i >= startBranch) {\r\n\t\t\t\t\t\t\t\tnextTransition = nextTransition[key] = Object.create(null)\r\n\t\t\t\t\t\t\t\tnextTransition.__keys__ = keys.slice(0, i + 1)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmakeRoom(position + size)\r\n\t\t\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\t\t\ttarget.copy(target, )\r\n\t\t\t\t\t\tobjectOffset\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttransition = nextTransition\r\n\t\t\t\t\tpack(object[key])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet id = transition.id\r\n\t\t\tif (!id) {\r\n\t\t\t\tid = transition.id = structures.push(transition.__keys__) + 63\r\n\t\t\t\tif (sharedStructures.onUpdate)\r\n\t\t\t\t\tsharedStructures.onUpdate(id, transition.__keys__)\r\n\t\t\t}\r\n\t\t\ttarget[objectOffset + start] = id\r\n\t\t}*/\r\n\t\t(object) => {\r\n\t\t\tlet keys = Object.keys(object)\r\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\r\n\t\t\tlet newTransitions = 0\r\n\t\t\tfor (let i =0, l = keys.length; i < l; i++) {\r\n\t\t\t\tlet key = keys[i]\r\n\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\tif (!nextTransition) {\r\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\r\n\t\t\t\t\tnewTransitions++\r\n\t\t\t\t}\r\n\t\t\t\ttransition = nextTransition\r\n\t\t\t}\r\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\r\n\t\t\tif (recordId) {\r\n\t\t\t\ttarget[position++] = recordId\r\n\t\t\t} else {\r\n\t\t\t\trecordId = structures.nextId++\r\n\t\t\t\tif (!recordId) {\r\n\t\t\t\t\trecordId = 0x40\r\n\t\t\t\t\tstructures.nextId = 0x41\r\n\t\t\t\t}\r\n\t\t\t\tif (recordId >= 0x80) {// cycle back around\r\n\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures + 0x40) + 1\r\n\t\t\t\t}\r\n\t\t\t\ttransition[RECORD_SYMBOL] = recordId\r\n\t\t\t\tstructures[0x3f & recordId] = keys\r\n\t\t\t\tif (sharedStructures && sharedStructures.length <= maxSharedStructures) {\r\n\t\t\t\t\ttarget[position++] = recordId\r\n\t\t\t\t\thasSharedUpdate = true\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\r\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\r\n\t\t\t\t\ttarget[position++] = recordId\r\n\t\t\t\t\tif (newTransitions)\r\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\r\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\r\n\t\t\t\t\tif (recordIdsToRemove.length >= 0x40 - maxSharedStructures)\r\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\r\n\t\t\t\t\trecordIdsToRemove.push(transition)\r\n\t\t\t\t\tpack(keys)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// now write the values\r\n\t\t\tfor (let i =0, l = keys.length; i < l; i++)\r\n\t\t\t\tpack(object[keys[i]])\r\n\t\t}\r\n\t\tconst makeRoom = (end) => {\r\n\t\t\tlet newSize\r\n\t\t\tif (end > 0x1000000) {\r\n\t\t\t\t// special handling for really large buffers\r\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\r\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\r\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\r\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x1000000) / 0x1000) * 0x1000)\r\n\t\t\t} else // faster handling for smaller buffers\r\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\r\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\r\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\r\n\t\t\tif (target.copy)\r\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\r\n\t\t\telse\r\n\t\t\t\tnewBuffer.set(target.slice(start, end))\r\n\t\t\tposition -= start\r\n\t\t\tstart = 0\r\n\t\t\tsafeEnd = newBuffer.length - 10\r\n\t\t\treturn target = newBuffer\r\n\t\t}\r\n\t}\r\n\tuseBuffer(buffer) {\r\n\t\t// this means we are finished using our own buffer and we can write over it safely\r\n\t\ttarget = buffer\r\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\r\n\t\tposition = 0\r\n\t}\r\n}\r\nexports.Packr = Packr\r\n\r\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\r\n\twhile (offset < endOffset) {\r\n\t\ttarget[targetOffset++] = source[offset++]\r\n\t}\r\n}\r\n\r\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\r\nextensions = [{\r\n\tpack(date, allocateForWrite) {\r\n\t\tlet seconds = date.getTime() / 1000\r\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\r\n\t\t\t// Timestamp 32\r\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\r\n\t\t\ttarget[position++] = 0xd6\r\n\t\t\ttarget[position++] = 0xff\r\n\t\t\ttargetView.setUint32(position, seconds)\r\n\t\t} else if (seconds > 0 && seconds < 0x400000000) {\r\n\t\t\t// Timestamp 64\r\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\r\n\t\t\ttarget[position++] = 0xd7\r\n\t\t\ttarget[position++] = 0xff\r\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\r\n\t\t\ttargetView.setUint32(position + 4, seconds)\r\n\t\t} else {\r\n\t\t\t// Timestamp 96\r\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\r\n\t\t\ttarget[position++] = 0xc7\r\n\t\t\ttarget[position++] = 12\r\n\t\t\ttarget[position++] = 0xff\r\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\r\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\r\n\t\t}\r\n\t}\r\n}, {\r\n\tpack(set, allocateForWrite, pack) {\r\n\t\tlet array = Array.from(set)\r\n\t\tif (this.structuredClone) {\r\n\t\t\tlet { target, position} = allocateForWrite(3)\r\n\t\t\ttarget[position++] = 0xd4\r\n\t\t\ttarget[position++] = 0x73 // 's' for Set\r\n\t\t\ttarget[position++] = 0\r\n\t\t}\r\n\t\tpack(array)\r\n\t}\r\n}, {\r\n\tpack(error, allocateForWrite, pack) {\r\n\t\tif (this.structuredClone) {\r\n\t\t\tlet { target, position} = allocateForWrite(3)\r\n\t\t\ttarget[position++] = 0xd4\r\n\t\t\ttarget[position++] = 0x65 // 'e' for error\r\n\t\t\ttarget[position++] = 0\r\n\t\t}\r\n\t\tpack([ error.name, error.message ])\r\n\t}\r\n}, {\r\n\tpack(regex, allocateForWrite, pack) {\r\n\t\tif (this.structuredClone) {\r\n\t\t\tlet { target, position} = allocateForWrite(3)\r\n\t\t\ttarget[position++] = 0xd4\r\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\r\n\t\t\ttarget[position++] = 0\r\n\t\t}\r\n\t\tpack([ regex.source, regex.flags ])\r\n\t}\r\n}, {\r\n\tpack(arrayBuffer, allocateForWrite) {\r\n\t\tif (this.structuredClone)\r\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\r\n\t\telse\r\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\r\n\t}\r\n}, {\r\n\tpack(typedArray, allocateForWrite) {\r\n\t\tlet constructor = typedArray.constructor\r\n\t\tif (constructor !== ByteArray && this.structuredClone)\r\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\r\n\t\telse\r\n\t\t\twriteBuffer(typedArray, allocateForWrite)\r\n\t}\r\n}, {\r\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\r\n\t\tlet { target, position} = allocateForWrite(1)\r\n\t\ttarget[position] = 0xc1\r\n\t}\r\n}]\r\n\r\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\r\n\tlet length = typedArray.byteLength\r\n\tif (length + 1 < 0x100) {\r\n\t\tvar { target, position } = allocateForWrite(4 + length)\r\n\t\ttarget[position++] = 0xc7\r\n\t\ttarget[position++] = length + 1\r\n\t} else if (length + 1 < 0x10000) {\r\n\t\tvar { target, position } = allocateForWrite(5 + length)\r\n\t\ttarget[position++] = 0xc8\r\n\t\ttarget[position++] = (length + 1) >> 8\r\n\t\ttarget[position++] = (length + 1) & 0xff\r\n\t} else {\r\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\r\n\t\ttarget[position++] = 0xc9\r\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\r\n\t\tposition += 4\r\n\t}\r\n\ttarget[position++] = 0x74 // \"t\" for typed array\r\n\ttarget[position++] = type\r\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\r\n}\r\nfunction writeBuffer(buffer, allocateForWrite) {\r\n\tlet length = buffer.byteLength\r\n\tvar target, position\r\n\tif (length < 0x100) {\r\n\t\tvar { target, position } = allocateForWrite(length + 2)\r\n\t\ttarget[position++] = 0xc4\r\n\t\ttarget[position++] = length\r\n\t} else if (length < 0x10000) {\r\n\t\tvar { target, position } = allocateForWrite(length + 3)\r\n\t\ttarget[position++] = 0xc5\r\n\t\ttarget[position++] = length >> 8\r\n\t\ttarget[position++] = length & 0xff\r\n\t} else {\r\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\r\n\t\ttarget[position++] = 0xc6\r\n\t\ttargetView.setUint32(position, length)\r\n\t\tposition += 4\r\n\t}\r\n\ttarget.set(buffer, position)\r\n}\r\n\r\nfunction writeExtensionData(result, target, position, type) {\r\n\tlet length = result.length\r\n\tswitch (length) {\r\n\t\tcase 1:\r\n\t\t\ttarget[position++] = 0xd4\r\n\t\t\tbreak\r\n\t\tcase 2:\r\n\t\t\ttarget[position++] = 0xd5\r\n\t\t\tbreak\r\n\t\tcase 4:\r\n\t\t\ttarget[position++] = 0xd6\r\n\t\t\tbreak\r\n\t\tcase 8:\r\n\t\t\ttarget[position++] = 0xd7\r\n\t\t\tbreak\r\n\t\tcase 16:\r\n\t\t\ttarget[position++] = 0xd8\r\n\t\t\tbreak\r\n\t\tdefault:\r\n\t\t\tif (length < 0x100) {\r\n\t\t\t\ttarget[position++] = 0xc7\r\n\t\t\t\ttarget[position++] = length\r\n\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\ttarget[position++] = 0xc8\r\n\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t} else {\r\n\t\t\t\ttarget[position++] = 0xc9\r\n\t\t\t\ttarget[position++] = length >> 24\r\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\r\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\r\n\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t}\r\n\t}\r\n\ttarget[position++] = type\r\n\ttarget.set(result, position)\r\n\tposition += length\r\n\treturn position\r\n}\r\n\r\nfunction insertIds(serialized, idsToInsert) {\r\n\t// insert the ids that need to be referenced for structured clones\r\n\tlet nextId\r\n\tlet distanceToMove = idsToInsert.length * 6\r\n\tlet lastEnd = serialized.length - distanceToMove\r\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\r\n\twhile (nextId = idsToInsert.pop()) {\r\n\t\tlet offset = nextId.offset\r\n\t\tlet id = nextId.id\r\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\r\n\t\tdistanceToMove -= 6\r\n\t\tlet position = offset + distanceToMove\r\n\t\tserialized[position++] = 0xd6\r\n\t\tserialized[position++] = 0x69 // 'i'\r\n\t\tserialized[position++] = id >> 24\r\n\t\tserialized[position++] = (id >> 16) & 0xff\r\n\t\tserialized[position++] = (id >> 8) & 0xff\r\n\t\tserialized[position++] = id & 0xff\r\n\t\tlastEnd = offset\r\n\t}\r\n\treturn serialized\r\n}\r\n\r\nexports.addExtension = function(extension) {\r\n\tif (extension.Class) {\r\n\t\tif (!extension.pack)\r\n\t\t\tthrow new Error('Extension has no pack function')\r\n\t\textensionClasses.unshift(extension.Class)\r\n\t\textensions.unshift(extension)\r\n\t}\r\n\tunpackModule.addExtension(extension)\r\n}\r\n\r\nlet defaultPackr = new Packr({ useRecords: false })\r\nexports.pack = defaultPackr.pack\r\nexports.encode = defaultPackr.pack\r\nObject.assign(exports, exports.FLOAT32_OPTIONS = unpackModule.FLOAT32_OPTIONS)\r\n","\"use strict\"\r\nlet decoder\r\ntry {\r\n\tdecoder = new TextDecoder()\r\n} catch(error) {}\r\nlet src\r\nlet srcEnd\r\nlet position = 0\r\nlet alreadySet\r\nconst EMPTY_ARRAY = []\r\nlet strings = EMPTY_ARRAY\r\nlet stringPosition = 0\r\nlet currentUnpackr = {}\r\nlet currentStructures\r\nlet srcString\r\nlet srcStringStart = 0\r\nlet srcStringEnd = 0\r\nlet referenceMap\r\nlet currentExtensions = []\r\nlet dataView\r\nlet defaultOptions = {\r\n\tuseRecords: false,\r\n\tmapsAsObjects: true\r\n}\r\nclass C1Type {}\r\nconst C1 = new C1Type()\r\nC1.name = 'MessagePack 0xC1'\r\n\r\nclass Unpackr {\r\n\tconstructor(options) {\r\n\t\tif (options) {\r\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\r\n\t\t\t\toptions.mapsAsObjects = true\r\n\t\t\tif (options.getStructures && !options.structures)\r\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\r\n\t\t}\r\n\t\tObject.assign(this, options)\r\n\t}\r\n\tunpack(source, end, continueReading) {\r\n\t\tif (src) {\r\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\r\n\t\t\treturn saveState(() => {\r\n\t\t\t\tclearSource()\r\n\t\t\t\treturn this ? this.unpack(source, end, continueReading) : Unpackr.prototype.unpack.call(defaultOptions, source, end, continueReading)\r\n\t\t\t})\r\n\t\t}\r\n\t\tsrcEnd = end > -1 ? end : source.length\r\n\t\tposition = 0\r\n\t\tstringPosition = 0\r\n\t\tsrcStringEnd = 0\r\n\t\tsrcString = null\r\n\t\tstrings = EMPTY_ARRAY\r\n\t\tsrc = source\r\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\r\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\r\n\t\t// new ones\r\n\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\r\n\t\tif (this) {\r\n\t\t\tcurrentUnpackr = this\r\n\t\t\tif (this.structures) {\r\n\t\t\t\tcurrentStructures = this.structures\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn read()\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif (position >= srcEnd || !continueReading) {\r\n\t\t\t\t\t\t// finished reading this source, cleanup references\r\n\t\t\t\t\t\tcurrentStructures = null\r\n\t\t\t\t\t\tsrc = null\r\n\t\t\t\t\t\tif (referenceMap)\r\n\t\t\t\t\t\t\treferenceMap = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\r\n\t\t\t\tcurrentStructures = []\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcurrentUnpackr = defaultOptions\r\n\t\t\tif (!currentStructures || currentStructures.length > 0)\r\n\t\t\t\tcurrentStructures = []\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn read()\r\n\t\t} finally {\r\n\t\t\tif (position >= srcEnd || !continueReading) {\r\n\t\t\t\tsrc = null\r\n\t\t\t\tif (referenceMap)\r\n\t\t\t\t\treferenceMap = null\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tunpackMultiple(source, forEach) {\r\n\t\ttry {\r\n\t\t\tlet unpackr = this\r\n\t\t\tlet size = source.length\r\n\t\t\tlet value = this ? this.unpack(source, size, true) : defaultUnpackr.unpack(source, size, true)\r\n\t\t\tlet values\r\n\t\t\tif (forEach) {\r\n\t\t\t\tforEach(value)\r\n\t\t\t\twhile(position < size) {\r\n\t\t\t\t\tif (forEach(read()) === false) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalues = [ value ]\r\n\t\t\t\twhile(position < size) {\r\n\t\t\t\t\tvalues.push(read())\r\n\t\t\t\t}\r\n\t\t\t\treturn values\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tclearSource()\r\n\t\t}\r\n\t}\r\n\tdecode(source, end) {\r\n\t\treturn this.unpack(source, end)\r\n\t}\r\n}\r\nexports.Decoder = exports.Unpackr = Unpackr\r\nexports.read = read\r\nexports.getPosition = () => {\r\n\treturn position\r\n}\r\n\r\nfunction read() {\r\n\tlet token = src[position++]\r\n\tif (token < 0xa0) {\r\n\t\tif (token < 0x80) {\r\n\t\t\tif (token < 0x40)\r\n\t\t\t\treturn token\r\n\t\t\telse {\r\n\t\t\t\tlet structure = currentStructures[token & 0x3f]\r\n\t\t\t\tif (structure) {\r\n\t\t\t\t\tif (!structure.read)\r\n\t\t\t\t\t\tstructure.read = createStructureReader(structure)\r\n\t\t\t\t\treturn structure.read()\r\n\t\t\t\t} else if (currentUnpackr.getStructures) {\r\n\t\t\t\t\tlet updatedStructures = saveState(() => {\r\n\t\t\t\t\t\t// save the state in case getStructures modifies our buffer\r\n\t\t\t\t\t\tsrc = null\r\n\t\t\t\t\t\treturn currentUnpackr.getStructures()\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (currentStructures === true)\r\n\t\t\t\t\t\tcurrentUnpackr.structures = currentStructures = updatedStructures\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\r\n\t\t\t\t\tstructure = currentStructures[token & 0x3f]\r\n\t\t\t\t\tif (structure) {\r\n\t\t\t\t\t\tif (!structure.read)\r\n\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\r\n\t\t\t\t\t\treturn structure.read()\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\treturn token\r\n\t\t\t\t} else\r\n\t\t\t\t\treturn token\r\n\t\t\t}\r\n\t\t} else if (token < 0x90) {\r\n\t\t\t// map\r\n\t\t\ttoken -= 0x80\r\n\t\t\tif (currentUnpackr.mapsAsObjects) {\r\n\t\t\t\tlet object = {}\r\n\t\t\t\tfor (let i = 0; i < token; i++) {\r\n\t\t\t\t\tobject[readKey()] = read()\r\n\t\t\t\t}\r\n\t\t\t\treturn object\r\n\t\t\t} else {\r\n\t\t\t\tlet map = new Map()\r\n\t\t\t\tfor (let i = 0; i < token; i++) {\r\n\t\t\t\t\tmap.set(read(), read())\r\n\t\t\t\t}\r\n\t\t\t\treturn map\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttoken -= 0x90\r\n\t\t\tlet array = new Array(token)\r\n\t\t\tfor (let i = 0; i < token; i++) {\r\n\t\t\t\tarray[i] = read()\r\n\t\t\t}\r\n\t\t\treturn array\r\n\t\t}\r\n\t} else if (token < 0xc0) {\r\n\t\t// fixstr\r\n\t\tlet length = token - 0xa0\r\n\t\tif (srcStringEnd >= position) {\r\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\r\n\t\t}\r\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\r\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\r\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\r\n\t\t\tif (string != null)\r\n\t\t\t\treturn string\r\n\t\t}\r\n\t\treturn readFixedString(length)\r\n\t} else {\r\n\t\tlet value\r\n\t\tswitch (token) {\r\n\t\t\tcase 0xc0: return null\r\n\t\t\tcase 0xc1: return C1; // \"never-used\", return special object to denote that\r\n\t\t\tcase 0xc2: return false\r\n\t\t\tcase 0xc3: return true\r\n\t\t\tcase 0xc4:\r\n\t\t\t\t// bin 8\r\n\t\t\t\treturn readBin(src[position++])\r\n\t\t\tcase 0xc5:\r\n\t\t\t\t// bin 16\r\n\t\t\t\tvalue = dataView.getUint16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\treturn readBin(value)\r\n\t\t\tcase 0xc6:\r\n\t\t\t\t// bin 32\r\n\t\t\t\tvalue = dataView.getUint32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\treturn readBin(value)\r\n\t\t\tcase 0xc7:\r\n\t\t\t\t// ext 8\r\n\t\t\t\treturn readExt(src[position++])\r\n\t\t\tcase 0xc8:\r\n\t\t\t\t// ext 16\r\n\t\t\t\tvalue = dataView.getUint16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\treturn readExt(value)\r\n\t\t\tcase 0xc9:\r\n\t\t\t\t// ext 32\r\n\t\t\t\tvalue = dataView.getUint32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\treturn readExt(value)\r\n\t\t\tcase 0xca:\r\n\t\t\t\tvalue = dataView.getFloat32(position)\r\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\r\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\r\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\r\n\t\t\t\t\tposition += 4\r\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\r\n\t\t\t\t}\r\n\t\t\t\tposition += 4\r\n\t\t\t\treturn value\r\n\t\t\tcase 0xcb:\r\n\t\t\t\tvalue = dataView.getFloat64(position)\r\n\t\t\t\tposition += 8\r\n\t\t\t\treturn value\r\n\t\t\t// uint handlers\r\n\t\t\tcase 0xcc:\r\n\t\t\t\treturn src[position++]\r\n\t\t\tcase 0xcd:\r\n\t\t\t\tvalue = dataView.getUint16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\treturn value\r\n\t\t\tcase 0xce:\r\n\t\t\t\tvalue = dataView.getUint32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\treturn value\r\n\t\t\tcase 0xcf:\r\n\t\t\t\tif (currentUnpackr.uint64AsNumber)\r\n\t\t\t\t\treturn src[position++] * 0x100000000000000 + src[position++] * 0x1000000000000 + src[position++] * 0x10000000000 + src[position++] * 0x100000000 +\r\n\t\t\t\t\t\tsrc[position++] * 0x1000000 + (src[position++] << 16) + (src[position++] << 8) + src[position++]\r\n\t\t\t\tvalue = dataView.getBigUint64(position)\r\n\t\t\t\tposition += 8\r\n\t\t\t\treturn value\r\n\r\n\t\t\t// int handlers\r\n\t\t\tcase 0xd0:\r\n\t\t\t\treturn dataView.getInt8(position++)\r\n\t\t\tcase 0xd1:\r\n\t\t\t\tvalue = dataView.getInt16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\treturn value\r\n\t\t\tcase 0xd2:\r\n\t\t\t\tvalue = dataView.getInt32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\treturn value\r\n\t\t\tcase 0xd3:\r\n\t\t\t\tvalue = dataView.getBigInt64(position)\r\n\t\t\t\tposition += 8\r\n\t\t\t\treturn value\r\n\r\n\t\t\tcase 0xd4:\r\n\t\t\t\t// fixext 1\r\n\t\t\t\tvalue = src[position++]\r\n\t\t\t\tif (value == 0x72) {\r\n\t\t\t\t\treturn recordDefinition(src[position++])\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (currentExtensions[value])\r\n\t\t\t\t\t\treturn currentExtensions[value]([src[position++]])\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\r\n\t\t\t\t}\r\n\t\t\tcase 0xd5:\r\n\t\t\t\t// fixext 2\r\n\t\t\t\treturn readExt(2)\r\n\t\t\tcase 0xd6:\r\n\t\t\t\t// fixext 4\r\n\t\t\t\treturn readExt(4)\r\n\t\t\tcase 0xd7:\r\n\t\t\t\t// fixext 8\r\n\t\t\t\treturn readExt(8)\r\n\t\t\tcase 0xd8:\r\n\t\t\t\t// fixext 16\r\n\t\t\t\treturn readExt(16)\r\n\t\t\tcase 0xd9:\r\n\t\t\t// str 8\r\n\t\t\t\tvalue = src[position++]\r\n\t\t\t\tif (srcStringEnd >= position) {\r\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\r\n\t\t\t\t}\r\n\t\t\t\treturn readString8(value)\r\n\t\t\tcase 0xda:\r\n\t\t\t// str 16\r\n\t\t\t\tvalue = dataView.getUint16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\tif (srcStringEnd >= position) {\r\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\r\n\t\t\t\t}\r\n\t\t\t\treturn readString16(value)\r\n\t\t\tcase 0xdb:\r\n\t\t\t// str 32\r\n\t\t\t\tvalue = dataView.getUint32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\tif (srcStringEnd >= position) {\r\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\r\n\t\t\t\t}\r\n\t\t\t\treturn readString32(value)\r\n\t\t\tcase 0xdc:\r\n\t\t\t// array 16\r\n\t\t\t\tvalue = dataView.getUint16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\treturn readArray(value)\r\n\t\t\tcase 0xdd:\r\n\t\t\t// array 32\r\n\t\t\t\tvalue = dataView.getUint32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\treturn readArray(value)\r\n\t\t\tcase 0xde:\r\n\t\t\t// map 16\r\n\t\t\t\tvalue = dataView.getUint16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\treturn readMap(value)\r\n\t\t\tcase 0xdf:\r\n\t\t\t// map 32\r\n\t\t\t\tvalue = dataView.getUint32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\treturn readMap(value)\r\n\t\t\tdefault: // negative int\r\n\t\t\t\tif (token >= 0xe0)\r\n\t\t\t\t\treturn token - 0x100\r\n\t\t\t\tif (token === undefined) {\r\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\r\n\t\t\t\t\terror.incomplete = true\r\n\t\t\t\t\tthrow error\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\r\n\r\n\t\t}\r\n\t}\r\n}\r\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\r\nfunction createStructureReader(structure) {\r\n\tfunction readObject() {\r\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\r\n\t\tif (readObject.count++ > 2) {\r\n\t\t\tthis.read = (new Function('r', 'return function(){return {' + structure.map(key => validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}}'))(read)\r\n\t\t\treturn this.read()\r\n\t\t}\r\n\t\tlet object = {}\r\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\r\n\t\t\tlet key = structure[i]\r\n\t\t\tobject[key] = read()\r\n\t\t}\r\n\t\treturn object\r\n\t}\r\n\treadObject.count = 0\r\n\treturn readObject\r\n}\r\n\r\nlet readFixedString = readStringJS\r\nlet readString8 = readStringJS\r\nlet readString16 = readStringJS\r\nlet readString32 = readStringJS\r\n\r\nexports.setExtractor = (extractStrings) => {\r\n\treadFixedString = readString(1)\r\n\treadString8 = readString(2)\r\n\treadString16 = readString(3)\r\n\treadString32 = readString(5)\r\n\tfunction readString(headerLength) {\r\n\t\treturn function readString(length) {\r\n\t\t\tlet string = strings[stringPosition++]\r\n\t\t\tif (string == null) {\r\n\t\t\t\tlet extraction = extractStrings(position - headerLength, srcEnd, src)\r\n\t\t\t\tif (typeof extraction == 'string') {\r\n\t\t\t\t\tstring = extraction\r\n\t\t\t\t\tstrings = EMPTY_ARRAY\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstrings = extraction\r\n\t\t\t\t\tstringPosition = 1\r\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\r\n\t\t\t\t\tstring = strings[0]\r\n\t\t\t\t\tif (string === undefined)\r\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet srcStringLength = string.length\r\n\t\t\tif (srcStringLength <= length) {\r\n\t\t\t\tposition += length\r\n\t\t\t\treturn string\r\n\t\t\t}\r\n\t\t\tsrcString = string\r\n\t\t\tsrcStringStart = position\r\n\t\t\tsrcStringEnd = position + srcStringLength\r\n\t\t\tposition += length\r\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\r\n\t\t}\r\n\t}\r\n}\r\nfunction readStringJS(length) {\r\n\tlet result\r\n\tif (length < 16) {\r\n\t\tif (result = shortStringInJS(length))\r\n\t\t\treturn result\r\n\t}\r\n\tif (length > 64 && decoder)\r\n\t\treturn decoder.decode(src.subarray(position, position += length))\r\n\tconst end = position + length\r\n\tconst units = []\r\n\tresult = ''\r\n\twhile (position < end) {\r\n\t\tconst byte1 = src[position++]\r\n\t\tif ((byte1 & 0x80) === 0) {\r\n\t\t\t// 1 byte\r\n\t\t\tunits.push(byte1)\r\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\r\n\t\t\t// 2 bytes\r\n\t\t\tconst byte2 = src[position++] & 0x3f\r\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\r\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\r\n\t\t\t// 3 bytes\r\n\t\t\tconst byte2 = src[position++] & 0x3f\r\n\t\t\tconst byte3 = src[position++] & 0x3f\r\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\r\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\r\n\t\t\t// 4 bytes\r\n\t\t\tconst byte2 = src[position++] & 0x3f\r\n\t\t\tconst byte3 = src[position++] & 0x3f\r\n\t\t\tconst byte4 = src[position++] & 0x3f\r\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\r\n\t\t\tif (unit > 0xffff) {\r\n\t\t\t\tunit -= 0x10000\r\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\r\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\r\n\t\t\t}\r\n\t\t\tunits.push(unit)\r\n\t\t} else {\r\n\t\t\tunits.push(byte1)\r\n\t\t}\r\n\r\n\t\tif (units.length >= 0x1000) {\r\n\t\t\tresult += fromCharCode.apply(String, units)\r\n\t\t\tunits.length = 0\r\n\t\t}\r\n\t}\r\n\r\n\tif (units.length > 0) {\r\n\t\tresult += fromCharCode.apply(String, units)\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\nfunction readArray(length) {\r\n\tlet array = new Array(length)\r\n\tfor (let i = 0; i < length; i++) {\r\n\t\tarray[i] = read()\r\n\t}\r\n\treturn array\r\n}\r\n\r\nfunction readMap(length) {\r\n\tif (currentUnpackr.mapsAsObjects) {\r\n\t\tlet object = {}\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tobject[readKey()] = read()\r\n\t\t}\r\n\t\treturn object\r\n\t} else {\r\n\t\tlet map = new Map()\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tmap.set(read(), read())\r\n\t\t}\r\n\t\treturn map\r\n\t}\r\n}\r\n\r\nlet fromCharCode = String.fromCharCode\r\nfunction longStringInJS(length) {\r\n\tlet start = position\r\n\tlet bytes = new Array(length)\r\n\tfor (let i = 0; i < length; i++) {\r\n\t\tconst byte = src[position++];\r\n\t\tif ((byte & 0x80) > 0) {\r\n\t\t\tposition = start\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tbytes[i] = byte\r\n    \t}\r\n    \treturn fromCharCode.apply(String, bytes)\r\n}\r\nfunction shortStringInJS(length) {\r\n\tif (length < 4) {\r\n\t\tif (length < 2) {\r\n\t\t\tif (length === 0)\r\n\t\t\t\treturn ''\r\n\t\t\telse {\r\n\t\t\t\tlet a = src[position++]\r\n\t\t\t\tif ((a & 0x80) > 1) {\r\n\t\t\t\t\tposition -= 1\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\treturn fromCharCode(a)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet a = src[position++]\r\n\t\t\tlet b = src[position++]\r\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\r\n\t\t\t\tposition -= 2\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (length < 3)\r\n\t\t\t\treturn fromCharCode(a, b)\r\n\t\t\tlet c = src[position++]\r\n\t\t\tif ((c & 0x80) > 0) {\r\n\t\t\t\tposition -= 3\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\treturn fromCharCode(a, b, c)\r\n\t\t}\r\n\t} else {\r\n\t\tlet a = src[position++]\r\n\t\tlet b = src[position++]\r\n\t\tlet c = src[position++]\r\n\t\tlet d = src[position++]\r\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\r\n\t\t\tposition -= 4\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (length < 6) {\r\n\t\t\tif (length === 4)\r\n\t\t\t\treturn fromCharCode(a, b, c, d)\r\n\t\t\telse {\r\n\t\t\t\tlet e = src[position++]\r\n\t\t\t\tif ((e & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 5\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\r\n\t\t\t}\r\n\t\t} else if (length < 8) {\r\n\t\t\tlet e = src[position++]\r\n\t\t\tlet f = src[position++]\r\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\r\n\t\t\t\tposition -= 6\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (length < 7)\r\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\r\n\t\t\tlet g = src[position++]\r\n\t\t\tif ((g & 0x80) > 0) {\r\n\t\t\t\tposition -= 7\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\r\n\t\t} else {\r\n\t\t\tlet e = src[position++]\r\n\t\t\tlet f = src[position++]\r\n\t\t\tlet g = src[position++]\r\n\t\t\tlet h = src[position++]\r\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\r\n\t\t\t\tposition -= 8\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (length < 10) {\r\n\t\t\t\tif (length === 8)\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet i = src[position++]\r\n\t\t\t\t\tif ((i & 0x80) > 0) {\r\n\t\t\t\t\t\tposition -= 9\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\r\n\t\t\t\t}\r\n\t\t\t} else if (length < 12) {\r\n\t\t\t\tlet i = src[position++]\r\n\t\t\t\tlet j = src[position++]\r\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 10\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (length < 11)\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\r\n\t\t\t\tlet k = src[position++]\r\n\t\t\t\tif ((k & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 11\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\r\n\t\t\t} else {\r\n\t\t\t\tlet i = src[position++]\r\n\t\t\t\tlet j = src[position++]\r\n\t\t\t\tlet k = src[position++]\r\n\t\t\t\tlet l = src[position++]\r\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 12\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (length < 14) {\r\n\t\t\t\t\tif (length === 12)\r\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlet m = src[position++]\r\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\r\n\t\t\t\t\t\t\tposition -= 13\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet m = src[position++]\r\n\t\t\t\t\tlet n = src[position++]\r\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\r\n\t\t\t\t\t\tposition -= 14\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (length < 15)\r\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\r\n\t\t\t\t\tlet o = src[position++]\r\n\t\t\t\t\tif ((o & 0x80) > 0) {\r\n\t\t\t\t\t\tposition -= 15\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction readBin(length) {\r\n\treturn currentUnpackr.copyBuffers ?\r\n\t\t// specifically use the copying slice (not the node one)\r\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\r\n\t\tsrc.subarray(position, position += length)\r\n}\r\nfunction readExt(length) {\r\n\tlet type = src[position++]\r\n\tif (currentExtensions[type]) {\r\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\r\n\t}\r\n\telse\r\n\t\tthrow new Error('Unknown extension type ' + type)\r\n}\r\n\r\nlet keyCache = new Array(4096)\r\nfunction readKey() {\r\n\tlet length = src[position++]\r\n\tif (length >= 0xa0 && length < 0xc0) {\r\n\t\t// fixstr, potentially use key cache\r\n\t\tlength = length - 0xa0\r\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\r\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\r\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\r\n\t\t\treturn readFixedString(length)\r\n\t} else { // not cacheable, go back and do a standard read\r\n\t\tposition--\r\n\t\treturn read()\r\n\t}\r\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\r\n\tlet entry = keyCache[key]\r\n\tlet checkPosition = position\r\n\tlet end = position + length - 3\r\n\tlet chunk\r\n\tlet i = 0\r\n\tif (entry && entry.bytes == length) {\r\n\t\twhile (checkPosition < end) {\r\n\t\t\tchunk = dataView.getUint32(checkPosition)\r\n\t\t\tif (chunk != entry[i++]) {\r\n\t\t\t\tcheckPosition = 0x70000000\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tcheckPosition += 4\r\n\t\t}\r\n\t\tend += 3\r\n\t\twhile (checkPosition < end) {\r\n\t\t\tchunk = src[checkPosition++]\r\n\t\t\tif (chunk != entry[i++]) {\r\n\t\t\t\tcheckPosition = 0x70000000\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (checkPosition === end) {\r\n\t\t\tposition = checkPosition\r\n\t\t\treturn entry.string\r\n\t\t}\r\n\t\tend -= 3\r\n\t\tcheckPosition = position\r\n\t}\r\n\tentry = []\r\n\tkeyCache[key] = entry\r\n\tentry.bytes = length\r\n\twhile (checkPosition < end) {\r\n\t\tchunk = dataView.getUint32(checkPosition)\r\n\t\tentry.push(chunk)\r\n\t\tcheckPosition += 4\r\n\t}\r\n\tend += 3\r\n\twhile (checkPosition < end) {\r\n\t\tchunk = src[checkPosition++]\r\n\t\tentry.push(chunk)\r\n\t}\r\n\t// for small blocks, avoiding the overhead of the extract call is helpful\r\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\r\n\tif (string != null)\r\n\t\treturn entry.string = string\r\n\treturn entry.string = readFixedString(length)\r\n}\r\n\r\n// the registration of the record definition extension (as \"r\")\r\nconst recordDefinition = (id) => {\r\n\tlet structure = currentStructures[id & 0x3f] = read()\r\n\tstructure.read = createStructureReader(structure)\r\n\treturn structure.read()\r\n}\r\nlet glbl = typeof window == 'object' ? window : global\r\ncurrentExtensions[0] = (data) => {} // notepack defines extension 0 to mean undefined, so use that as the default here\r\n\r\ncurrentExtensions[0x65] = () => {\r\n\tlet data = read()\r\n\treturn (glbl[data[0]] || Error)(data[1])\r\n}\r\n\r\ncurrentExtensions[0x69] = (data) => {\r\n\t// id extension (for structured clones)\r\n\tlet id = dataView.getUint32(position - 4)\r\n\tif (!referenceMap)\r\n\t\treferenceMap = new Map()\r\n\tlet token = src[position]\r\n\tlet target\r\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\r\n\t// ahead past references to record structure definitions\r\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\r\n\t\ttarget = []\r\n\telse\r\n\t\ttarget = {}\r\n\r\n\tlet refEntry = { target } // a placeholder object\r\n\treferenceMap.set(id, refEntry)\r\n\tlet targetProperties = read() // read the next value as the target object to id\r\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\r\n\t\treturn Object.assign(target, targetProperties)\r\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\r\n\treturn targetProperties // no cycle, can just use the returned read object\r\n}\r\n\r\ncurrentExtensions[0x70] = (data) => {\r\n\t// pointer extension (for structured clones)\r\n\tlet id = dataView.getUint32(position - 4)\r\n\tlet refEntry = referenceMap.get(id)\r\n\trefEntry.used = true\r\n\treturn refEntry.target\r\n}\r\n\r\ncurrentExtensions[0x73] = () => new Set(read())\r\n\r\nconst typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\r\n\r\ncurrentExtensions[0x74] = (data) => {\r\n\tlet typeCode = data[0]\r\n\tlet typedArrayName = typedArrays[typeCode]\r\n\tif (!typedArrayName)\r\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\r\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\r\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\r\n}\r\ncurrentExtensions[0x78] = () => {\r\n\tlet data = read()\r\n\treturn new RegExp(data[0], data[1])\r\n}\r\n\r\ncurrentExtensions[0xff] = (data) => {\r\n\t// 32-bit date extension\r\n\tif (data.length == 4)\r\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\r\n\telse if (data.length == 8)\r\n\t\treturn new Date(\r\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\r\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\r\n\telse if (data.length == 12)// TODO: Implement support for negative\r\n\t\treturn new Date(\r\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\r\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\r\n\telse\r\n\t\tthrow new Error('Invalid timestamp length')\r\n} // notepack defines extension 0 to mean undefined, so use that as the default here\r\n// registration of bulk record definition?\r\n// currentExtensions[0x52] = () =>\r\n\r\nfunction saveState(callback) {\r\n\tlet savedSrcEnd = srcEnd\r\n\tlet savedPosition = position\r\n\tlet savedStringPosition = stringPosition\r\n\tlet savedSrcStringStart = srcStringStart\r\n\tlet savedSrcStringEnd = srcStringEnd\r\n\tlet savedSrcString = srcString\r\n\tlet savedStrings = strings\r\n\tlet savedReferenceMap = referenceMap\r\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\r\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\r\n\tlet savedStructures = currentStructures\r\n\tlet savedPackr = currentUnpackr\r\n\tlet value = callback()\r\n\tsrcEnd = savedSrcEnd\r\n\tposition = savedPosition\r\n\tstringPosition = savedStringPosition\r\n\tsrcStringStart = savedSrcStringStart\r\n\tsrcStringEnd = savedSrcStringEnd\r\n\tsrcString = savedSrcString\r\n\tstrings = savedStrings\r\n\treferenceMap = savedReferenceMap\r\n\tsrc = savedSrc\r\n\tcurrentStructures = savedStructures\r\n\tcurrentUnpackr = savedPackr\r\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\r\n\treturn value\r\n}\r\nexports.clearSource = clearSource\r\nfunction clearSource() {\r\n\tsrc = null\r\n\treferenceMap = null\r\n\tcurrentStructures = null\r\n}\r\n\r\nexports.addExtension = function(extension) {\r\n\tcurrentExtensions[extension.type] = extension.unpack\r\n}\r\n\r\nlet mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\r\nfor (let i = 0; i < 256; i++) {\r\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\r\n}\r\nexports.mult10 = mult10\r\nexports.typedArrays = typedArrays\r\nexports.useRecords = false\r\nexports.mapsAsObjects = true\r\nexports.C1 = C1\r\nexports.C1Type = C1Type\r\nlet defaultUnpackr = new Unpackr({ useRecords: false })\r\nexports.unpack = defaultUnpackr.unpack\r\nexports.unpackMultiple = defaultUnpackr.unpackMultiple\r\nexports.decode = defaultUnpackr.unpack\r\nexports.FLOAT32_OPTIONS = {\r\n\tNEVER: 0,\r\n\tALWAYS: 1,\r\n\tDECIMAL_ROUND: 3,\r\n\tDECIMAL_FIT: 4\r\n}","exports.Packr = require('./pack').Packr\r\nexports.Encoder = exports.Packr\r\nexports.Unpackr = require('./unpack').Unpackr\r\nexports.Decoder = exports.Unpackr\r\nexports.addExtension = require('./pack').addExtension\r\nlet packr = new exports.Packr({ useRecords: false })\r\nexports.unpack = packr.unpack\r\nexports.unpackMultiple = packr.unpackMultiple\r\nexports.pack = packr.pack\r\nexports.decode = packr.unpack\r\nexports.encode = packr.pack\r\nexports.FLOAT32_OPTIONS = require('./unpack').FLOAT32_OPTIONS\r\nObject.assign(exports, {\r\n\tALWAYS:1,\r\n\tDECIMAL_ROUND: 3,\r\n\tDECIMAL_FIT: 4\r\n})\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}